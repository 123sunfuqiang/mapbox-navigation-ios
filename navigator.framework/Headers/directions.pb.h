// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: directions.proto

#ifndef PROTOBUF_directions_2eproto__INCLUDED
#define PROTOBUF_directions_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_directions_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[15];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsDirectionsLocationImpl();
void InitDefaultsDirectionsLocation();
void InitDefaultsDirectionsBoundingBoxImpl();
void InitDefaultsDirectionsBoundingBox();
void InitDefaultsDirectionsSummaryImpl();
void InitDefaultsDirectionsSummary();
void InitDefaultsDirectionsBannerComponentImpl();
void InitDefaultsDirectionsBannerComponent();
void InitDefaultsDirectionsBannerSectionImpl();
void InitDefaultsDirectionsBannerSection();
void InitDefaultsDirectionsBannerInstructionImpl();
void InitDefaultsDirectionsBannerInstruction();
void InitDefaultsDirectionsVoiceInstructionImpl();
void InitDefaultsDirectionsVoiceInstruction();
void InitDefaultsDirectionsLaneImpl();
void InitDefaultsDirectionsLane();
void InitDefaultsDirectionsIntersectionImpl();
void InitDefaultsDirectionsIntersection();
void InitDefaultsDirectionsStreetNameImpl();
void InitDefaultsDirectionsStreetName();
void InitDefaultsDirectionsManeuverImpl();
void InitDefaultsDirectionsManeuver();
void InitDefaultsDirectionsStepImpl();
void InitDefaultsDirectionsStep();
void InitDefaultsDirectionsLegImpl();
void InitDefaultsDirectionsLeg();
void InitDefaultsDirectionsRouteImpl();
void InitDefaultsDirectionsRoute();
void InitDefaultsDirectionsImpl();
void InitDefaultsDirections();
inline void InitDefaults() {
  InitDefaultsDirectionsLocation();
  InitDefaultsDirectionsBoundingBox();
  InitDefaultsDirectionsSummary();
  InitDefaultsDirectionsBannerComponent();
  InitDefaultsDirectionsBannerSection();
  InitDefaultsDirectionsBannerInstruction();
  InitDefaultsDirectionsVoiceInstruction();
  InitDefaultsDirectionsLane();
  InitDefaultsDirectionsIntersection();
  InitDefaultsDirectionsStreetName();
  InitDefaultsDirectionsManeuver();
  InitDefaultsDirectionsStep();
  InitDefaultsDirectionsLeg();
  InitDefaultsDirectionsRoute();
  InitDefaultsDirections();
}
}  // namespace protobuf_directions_2eproto
namespace navigator {
class Directions;
class DirectionsDefaultTypeInternal;
extern DirectionsDefaultTypeInternal _Directions_default_instance_;
class DirectionsBannerComponent;
class DirectionsBannerComponentDefaultTypeInternal;
extern DirectionsBannerComponentDefaultTypeInternal _DirectionsBannerComponent_default_instance_;
class DirectionsBannerInstruction;
class DirectionsBannerInstructionDefaultTypeInternal;
extern DirectionsBannerInstructionDefaultTypeInternal _DirectionsBannerInstruction_default_instance_;
class DirectionsBannerSection;
class DirectionsBannerSectionDefaultTypeInternal;
extern DirectionsBannerSectionDefaultTypeInternal _DirectionsBannerSection_default_instance_;
class DirectionsBoundingBox;
class DirectionsBoundingBoxDefaultTypeInternal;
extern DirectionsBoundingBoxDefaultTypeInternal _DirectionsBoundingBox_default_instance_;
class DirectionsIntersection;
class DirectionsIntersectionDefaultTypeInternal;
extern DirectionsIntersectionDefaultTypeInternal _DirectionsIntersection_default_instance_;
class DirectionsLane;
class DirectionsLaneDefaultTypeInternal;
extern DirectionsLaneDefaultTypeInternal _DirectionsLane_default_instance_;
class DirectionsLeg;
class DirectionsLegDefaultTypeInternal;
extern DirectionsLegDefaultTypeInternal _DirectionsLeg_default_instance_;
class DirectionsLocation;
class DirectionsLocationDefaultTypeInternal;
extern DirectionsLocationDefaultTypeInternal _DirectionsLocation_default_instance_;
class DirectionsManeuver;
class DirectionsManeuverDefaultTypeInternal;
extern DirectionsManeuverDefaultTypeInternal _DirectionsManeuver_default_instance_;
class DirectionsRoute;
class DirectionsRouteDefaultTypeInternal;
extern DirectionsRouteDefaultTypeInternal _DirectionsRoute_default_instance_;
class DirectionsStep;
class DirectionsStepDefaultTypeInternal;
extern DirectionsStepDefaultTypeInternal _DirectionsStep_default_instance_;
class DirectionsStreetName;
class DirectionsStreetNameDefaultTypeInternal;
extern DirectionsStreetNameDefaultTypeInternal _DirectionsStreetName_default_instance_;
class DirectionsSummary;
class DirectionsSummaryDefaultTypeInternal;
extern DirectionsSummaryDefaultTypeInternal _DirectionsSummary_default_instance_;
class DirectionsVoiceInstruction;
class DirectionsVoiceInstructionDefaultTypeInternal;
extern DirectionsVoiceInstructionDefaultTypeInternal _DirectionsVoiceInstruction_default_instance_;
}  // namespace navigator
namespace navigator {

enum DirectionsIntersection_Class {
  DirectionsIntersection_Class__ = 0,
  DirectionsIntersection_Class_toll = 1,
  DirectionsIntersection_Class_ferry = 2,
  DirectionsIntersection_Class_restricted = 3,
  DirectionsIntersection_Class_motorway = 4,
  DirectionsIntersection_Class_tunnel = 5
};
bool DirectionsIntersection_Class_IsValid(int value);
const DirectionsIntersection_Class DirectionsIntersection_Class_Class_MIN = DirectionsIntersection_Class__;
const DirectionsIntersection_Class DirectionsIntersection_Class_Class_MAX = DirectionsIntersection_Class_tunnel;
const int DirectionsIntersection_Class_Class_ARRAYSIZE = DirectionsIntersection_Class_Class_MAX + 1;

const ::google::protobuf::EnumDescriptor* DirectionsIntersection_Class_descriptor();
inline const ::std::string& DirectionsIntersection_Class_Name(DirectionsIntersection_Class value) {
  return ::google::protobuf::internal::NameOfEnum(
    DirectionsIntersection_Class_descriptor(), value);
}
inline bool DirectionsIntersection_Class_Parse(
    const ::std::string& name, DirectionsIntersection_Class* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DirectionsIntersection_Class>(
    DirectionsIntersection_Class_descriptor(), name, value);
}
// ===================================================================

class DirectionsLocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.DirectionsLocation) */ {
 public:
  DirectionsLocation();
  virtual ~DirectionsLocation();

  DirectionsLocation(const DirectionsLocation& from);

  inline DirectionsLocation& operator=(const DirectionsLocation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectionsLocation(DirectionsLocation&& from) noexcept
    : DirectionsLocation() {
    *this = ::std::move(from);
  }

  inline DirectionsLocation& operator=(DirectionsLocation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectionsLocation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectionsLocation* internal_default_instance() {
    return reinterpret_cast<const DirectionsLocation*>(
               &_DirectionsLocation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DirectionsLocation* other);
  friend void swap(DirectionsLocation& a, DirectionsLocation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectionsLocation* New() const PROTOBUF_FINAL { return New(NULL); }

  DirectionsLocation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DirectionsLocation& from);
  void MergeFrom(const DirectionsLocation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DirectionsLocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string name = 5;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 5;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string street = 6;
  bool has_street() const;
  void clear_street();
  static const int kStreetFieldNumber = 6;
  const ::std::string& street() const;
  void set_street(const ::std::string& value);
  #if LANG_CXX11
  void set_street(::std::string&& value);
  #endif
  void set_street(const char* value);
  void set_street(const char* value, size_t size);
  ::std::string* mutable_street();
  ::std::string* release_street();
  void set_allocated_street(::std::string* street);

  // optional string city = 7;
  bool has_city() const;
  void clear_city();
  static const int kCityFieldNumber = 7;
  const ::std::string& city() const;
  void set_city(const ::std::string& value);
  #if LANG_CXX11
  void set_city(::std::string&& value);
  #endif
  void set_city(const char* value);
  void set_city(const char* value, size_t size);
  ::std::string* mutable_city();
  ::std::string* release_city();
  void set_allocated_city(::std::string* city);

  // optional string state = 8;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 8;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  #if LANG_CXX11
  void set_state(::std::string&& value);
  #endif
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // optional string postal_code = 9;
  bool has_postal_code() const;
  void clear_postal_code();
  static const int kPostalCodeFieldNumber = 9;
  const ::std::string& postal_code() const;
  void set_postal_code(const ::std::string& value);
  #if LANG_CXX11
  void set_postal_code(::std::string&& value);
  #endif
  void set_postal_code(const char* value);
  void set_postal_code(const char* value, size_t size);
  ::std::string* mutable_postal_code();
  ::std::string* release_postal_code();
  void set_allocated_postal_code(::std::string* postal_code);

  // optional string country = 10;
  bool has_country() const;
  void clear_country();
  static const int kCountryFieldNumber = 10;
  const ::std::string& country() const;
  void set_country(const ::std::string& value);
  #if LANG_CXX11
  void set_country(::std::string&& value);
  #endif
  void set_country(const char* value);
  void set_country(const char* value, size_t size);
  ::std::string* mutable_country();
  ::std::string* release_country();
  void set_allocated_country(::std::string* country);

  // optional string date_time = 11;
  bool has_date_time() const;
  void clear_date_time();
  static const int kDateTimeFieldNumber = 11;
  const ::std::string& date_time() const;
  void set_date_time(const ::std::string& value);
  #if LANG_CXX11
  void set_date_time(::std::string&& value);
  #endif
  void set_date_time(const char* value);
  void set_date_time(const char* value, size_t size);
  ::std::string* mutable_date_time();
  ::std::string* release_date_time();
  void set_allocated_date_time(::std::string* date_time);

  // optional string side_of_street = 12;
  bool has_side_of_street() const;
  void clear_side_of_street();
  static const int kSideOfStreetFieldNumber = 12;
  const ::std::string& side_of_street() const;
  void set_side_of_street(const ::std::string& value);
  #if LANG_CXX11
  void set_side_of_street(::std::string&& value);
  #endif
  void set_side_of_street(const char* value);
  void set_side_of_street(const char* value, size_t size);
  ::std::string* mutable_side_of_street();
  ::std::string* release_side_of_street();
  void set_allocated_side_of_street(::std::string* side_of_street);

  // optional float lat = 1;
  bool has_lat() const;
  void clear_lat();
  static const int kLatFieldNumber = 1;
  float lat() const;
  void set_lat(float value);

  // optional float lon = 2;
  bool has_lon() const;
  void clear_lon();
  static const int kLonFieldNumber = 2;
  float lon() const;
  void set_lon(float value);

  // optional uint32 bearing = 4;
  bool has_bearing() const;
  void clear_bearing();
  static const int kBearingFieldNumber = 4;
  ::google::protobuf::uint32 bearing() const;
  void set_bearing(::google::protobuf::uint32 value);

  // optional uint32 original_index = 13;
  bool has_original_index() const;
  void clear_original_index();
  static const int kOriginalIndexFieldNumber = 13;
  ::google::protobuf::uint32 original_index() const;
  void set_original_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:navigator.DirectionsLocation)
 private:
  void set_has_lat();
  void clear_has_lat();
  void set_has_lon();
  void clear_has_lon();
  void set_has_type();
  void clear_has_type();
  void set_has_bearing();
  void clear_has_bearing();
  void set_has_name();
  void clear_has_name();
  void set_has_street();
  void clear_has_street();
  void set_has_city();
  void clear_has_city();
  void set_has_state();
  void clear_has_state();
  void set_has_postal_code();
  void clear_has_postal_code();
  void set_has_country();
  void clear_has_country();
  void set_has_date_time();
  void clear_has_date_time();
  void set_has_side_of_street();
  void clear_has_side_of_street();
  void set_has_original_index();
  void clear_has_original_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr street_;
  ::google::protobuf::internal::ArenaStringPtr city_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  ::google::protobuf::internal::ArenaStringPtr postal_code_;
  ::google::protobuf::internal::ArenaStringPtr country_;
  ::google::protobuf::internal::ArenaStringPtr date_time_;
  ::google::protobuf::internal::ArenaStringPtr side_of_street_;
  float lat_;
  float lon_;
  ::google::protobuf::uint32 bearing_;
  ::google::protobuf::uint32 original_index_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsLocationImpl();
};
// -------------------------------------------------------------------

class DirectionsBoundingBox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.DirectionsBoundingBox) */ {
 public:
  DirectionsBoundingBox();
  virtual ~DirectionsBoundingBox();

  DirectionsBoundingBox(const DirectionsBoundingBox& from);

  inline DirectionsBoundingBox& operator=(const DirectionsBoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectionsBoundingBox(DirectionsBoundingBox&& from) noexcept
    : DirectionsBoundingBox() {
    *this = ::std::move(from);
  }

  inline DirectionsBoundingBox& operator=(DirectionsBoundingBox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectionsBoundingBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectionsBoundingBox* internal_default_instance() {
    return reinterpret_cast<const DirectionsBoundingBox*>(
               &_DirectionsBoundingBox_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(DirectionsBoundingBox* other);
  friend void swap(DirectionsBoundingBox& a, DirectionsBoundingBox& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectionsBoundingBox* New() const PROTOBUF_FINAL { return New(NULL); }

  DirectionsBoundingBox* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DirectionsBoundingBox& from);
  void MergeFrom(const DirectionsBoundingBox& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DirectionsBoundingBox* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float min_lat = 1;
  bool has_min_lat() const;
  void clear_min_lat();
  static const int kMinLatFieldNumber = 1;
  float min_lat() const;
  void set_min_lat(float value);

  // optional float min_lon = 2;
  bool has_min_lon() const;
  void clear_min_lon();
  static const int kMinLonFieldNumber = 2;
  float min_lon() const;
  void set_min_lon(float value);

  // optional float max_lat = 3;
  bool has_max_lat() const;
  void clear_max_lat();
  static const int kMaxLatFieldNumber = 3;
  float max_lat() const;
  void set_max_lat(float value);

  // optional float max_lon = 4;
  bool has_max_lon() const;
  void clear_max_lon();
  static const int kMaxLonFieldNumber = 4;
  float max_lon() const;
  void set_max_lon(float value);

  // @@protoc_insertion_point(class_scope:navigator.DirectionsBoundingBox)
 private:
  void set_has_min_lat();
  void clear_has_min_lat();
  void set_has_min_lon();
  void clear_has_min_lon();
  void set_has_max_lat();
  void clear_has_max_lat();
  void set_has_max_lon();
  void clear_has_max_lon();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float min_lat_;
  float min_lon_;
  float max_lat_;
  float max_lon_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsBoundingBoxImpl();
};
// -------------------------------------------------------------------

class DirectionsSummary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.DirectionsSummary) */ {
 public:
  DirectionsSummary();
  virtual ~DirectionsSummary();

  DirectionsSummary(const DirectionsSummary& from);

  inline DirectionsSummary& operator=(const DirectionsSummary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectionsSummary(DirectionsSummary&& from) noexcept
    : DirectionsSummary() {
    *this = ::std::move(from);
  }

  inline DirectionsSummary& operator=(DirectionsSummary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectionsSummary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectionsSummary* internal_default_instance() {
    return reinterpret_cast<const DirectionsSummary*>(
               &_DirectionsSummary_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(DirectionsSummary* other);
  friend void swap(DirectionsSummary& a, DirectionsSummary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectionsSummary* New() const PROTOBUF_FINAL { return New(NULL); }

  DirectionsSummary* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DirectionsSummary& from);
  void MergeFrom(const DirectionsSummary& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DirectionsSummary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional .navigator.DirectionsBoundingBox bounding_box = 4;
  bool has_bounding_box() const;
  void clear_bounding_box();
  static const int kBoundingBoxFieldNumber = 4;
  const ::navigator::DirectionsBoundingBox& bounding_box() const;
  ::navigator::DirectionsBoundingBox* release_bounding_box();
  ::navigator::DirectionsBoundingBox* mutable_bounding_box();
  void set_allocated_bounding_box(::navigator::DirectionsBoundingBox* bounding_box);

  // optional float distance = 2;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  float distance() const;
  void set_distance(float value);

  // optional uint32 duration = 3;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 3;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:navigator.DirectionsSummary)
 private:
  void set_has_text();
  void clear_has_text();
  void set_has_distance();
  void clear_has_distance();
  void set_has_duration();
  void clear_has_duration();
  void set_has_bounding_box();
  void clear_has_bounding_box();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::navigator::DirectionsBoundingBox* bounding_box_;
  float distance_;
  ::google::protobuf::uint32 duration_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsSummaryImpl();
};
// -------------------------------------------------------------------

class DirectionsBannerComponent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.DirectionsBannerComponent) */ {
 public:
  DirectionsBannerComponent();
  virtual ~DirectionsBannerComponent();

  DirectionsBannerComponent(const DirectionsBannerComponent& from);

  inline DirectionsBannerComponent& operator=(const DirectionsBannerComponent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectionsBannerComponent(DirectionsBannerComponent&& from) noexcept
    : DirectionsBannerComponent() {
    *this = ::std::move(from);
  }

  inline DirectionsBannerComponent& operator=(DirectionsBannerComponent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectionsBannerComponent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectionsBannerComponent* internal_default_instance() {
    return reinterpret_cast<const DirectionsBannerComponent*>(
               &_DirectionsBannerComponent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(DirectionsBannerComponent* other);
  friend void swap(DirectionsBannerComponent& a, DirectionsBannerComponent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectionsBannerComponent* New() const PROTOBUF_FINAL { return New(NULL); }

  DirectionsBannerComponent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DirectionsBannerComponent& from);
  void MergeFrom(const DirectionsBannerComponent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DirectionsBannerComponent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional string abbr = 3;
  bool has_abbr() const;
  void clear_abbr();
  static const int kAbbrFieldNumber = 3;
  const ::std::string& abbr() const;
  void set_abbr(const ::std::string& value);
  #if LANG_CXX11
  void set_abbr(::std::string&& value);
  #endif
  void set_abbr(const char* value);
  void set_abbr(const char* value, size_t size);
  ::std::string* mutable_abbr();
  ::std::string* release_abbr();
  void set_allocated_abbr(::std::string* abbr);

  // optional string image_baseurl = 5;
  bool has_image_baseurl() const;
  void clear_image_baseurl();
  static const int kImageBaseurlFieldNumber = 5;
  const ::std::string& image_baseurl() const;
  void set_image_baseurl(const ::std::string& value);
  #if LANG_CXX11
  void set_image_baseurl(::std::string&& value);
  #endif
  void set_image_baseurl(const char* value);
  void set_image_baseurl(const char* value, size_t size);
  ::std::string* mutable_image_baseurl();
  ::std::string* release_image_baseurl();
  void set_allocated_image_baseurl(::std::string* image_baseurl);

  // optional uint32 abbr_priority = 4;
  bool has_abbr_priority() const;
  void clear_abbr_priority();
  static const int kAbbrPriorityFieldNumber = 4;
  ::google::protobuf::uint32 abbr_priority() const;
  void set_abbr_priority(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:navigator.DirectionsBannerComponent)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_text();
  void clear_has_text();
  void set_has_abbr();
  void clear_has_abbr();
  void set_has_abbr_priority();
  void clear_has_abbr_priority();
  void set_has_image_baseurl();
  void clear_has_image_baseurl();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr abbr_;
  ::google::protobuf::internal::ArenaStringPtr image_baseurl_;
  ::google::protobuf::uint32 abbr_priority_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsBannerComponentImpl();
};
// -------------------------------------------------------------------

class DirectionsBannerSection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.DirectionsBannerSection) */ {
 public:
  DirectionsBannerSection();
  virtual ~DirectionsBannerSection();

  DirectionsBannerSection(const DirectionsBannerSection& from);

  inline DirectionsBannerSection& operator=(const DirectionsBannerSection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectionsBannerSection(DirectionsBannerSection&& from) noexcept
    : DirectionsBannerSection() {
    *this = ::std::move(from);
  }

  inline DirectionsBannerSection& operator=(DirectionsBannerSection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectionsBannerSection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectionsBannerSection* internal_default_instance() {
    return reinterpret_cast<const DirectionsBannerSection*>(
               &_DirectionsBannerSection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DirectionsBannerSection* other);
  friend void swap(DirectionsBannerSection& a, DirectionsBannerSection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectionsBannerSection* New() const PROTOBUF_FINAL { return New(NULL); }

  DirectionsBannerSection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DirectionsBannerSection& from);
  void MergeFrom(const DirectionsBannerSection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DirectionsBannerSection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .navigator.DirectionsBannerComponent components = 2;
  int components_size() const;
  void clear_components();
  static const int kComponentsFieldNumber = 2;
  const ::navigator::DirectionsBannerComponent& components(int index) const;
  ::navigator::DirectionsBannerComponent* mutable_components(int index);
  ::navigator::DirectionsBannerComponent* add_components();
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsBannerComponent >*
      mutable_components();
  const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsBannerComponent >&
      components() const;

  // optional string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional string type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string modifier = 4;
  bool has_modifier() const;
  void clear_modifier();
  static const int kModifierFieldNumber = 4;
  const ::std::string& modifier() const;
  void set_modifier(const ::std::string& value);
  #if LANG_CXX11
  void set_modifier(::std::string&& value);
  #endif
  void set_modifier(const char* value);
  void set_modifier(const char* value, size_t size);
  ::std::string* mutable_modifier();
  ::std::string* release_modifier();
  void set_allocated_modifier(::std::string* modifier);

  // optional string driving_side = 6;
  bool has_driving_side() const;
  void clear_driving_side();
  static const int kDrivingSideFieldNumber = 6;
  const ::std::string& driving_side() const;
  void set_driving_side(const ::std::string& value);
  #if LANG_CXX11
  void set_driving_side(::std::string&& value);
  #endif
  void set_driving_side(const char* value);
  void set_driving_side(const char* value, size_t size);
  ::std::string* mutable_driving_side();
  ::std::string* release_driving_side();
  void set_allocated_driving_side(::std::string* driving_side);

  // optional uint32 degrees = 5;
  bool has_degrees() const;
  void clear_degrees();
  static const int kDegreesFieldNumber = 5;
  ::google::protobuf::uint32 degrees() const;
  void set_degrees(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:navigator.DirectionsBannerSection)
 private:
  void set_has_text();
  void clear_has_text();
  void set_has_type();
  void clear_has_type();
  void set_has_modifier();
  void clear_has_modifier();
  void set_has_degrees();
  void clear_has_degrees();
  void set_has_driving_side();
  void clear_has_driving_side();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsBannerComponent > components_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr modifier_;
  ::google::protobuf::internal::ArenaStringPtr driving_side_;
  ::google::protobuf::uint32 degrees_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsBannerSectionImpl();
};
// -------------------------------------------------------------------

class DirectionsBannerInstruction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.DirectionsBannerInstruction) */ {
 public:
  DirectionsBannerInstruction();
  virtual ~DirectionsBannerInstruction();

  DirectionsBannerInstruction(const DirectionsBannerInstruction& from);

  inline DirectionsBannerInstruction& operator=(const DirectionsBannerInstruction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectionsBannerInstruction(DirectionsBannerInstruction&& from) noexcept
    : DirectionsBannerInstruction() {
    *this = ::std::move(from);
  }

  inline DirectionsBannerInstruction& operator=(DirectionsBannerInstruction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectionsBannerInstruction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectionsBannerInstruction* internal_default_instance() {
    return reinterpret_cast<const DirectionsBannerInstruction*>(
               &_DirectionsBannerInstruction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(DirectionsBannerInstruction* other);
  friend void swap(DirectionsBannerInstruction& a, DirectionsBannerInstruction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectionsBannerInstruction* New() const PROTOBUF_FINAL { return New(NULL); }

  DirectionsBannerInstruction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DirectionsBannerInstruction& from);
  void MergeFrom(const DirectionsBannerInstruction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DirectionsBannerInstruction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .navigator.DirectionsBannerSection primary = 2;
  bool has_primary() const;
  void clear_primary();
  static const int kPrimaryFieldNumber = 2;
  const ::navigator::DirectionsBannerSection& primary() const;
  ::navigator::DirectionsBannerSection* release_primary();
  ::navigator::DirectionsBannerSection* mutable_primary();
  void set_allocated_primary(::navigator::DirectionsBannerSection* primary);

  // optional .navigator.DirectionsBannerSection secondary = 3;
  bool has_secondary() const;
  void clear_secondary();
  static const int kSecondaryFieldNumber = 3;
  const ::navigator::DirectionsBannerSection& secondary() const;
  ::navigator::DirectionsBannerSection* release_secondary();
  ::navigator::DirectionsBannerSection* mutable_secondary();
  void set_allocated_secondary(::navigator::DirectionsBannerSection* secondary);

  // optional .navigator.DirectionsBannerSection sub = 4;
  bool has_sub() const;
  void clear_sub();
  static const int kSubFieldNumber = 4;
  const ::navigator::DirectionsBannerSection& sub() const;
  ::navigator::DirectionsBannerSection* release_sub();
  ::navigator::DirectionsBannerSection* mutable_sub();
  void set_allocated_sub(::navigator::DirectionsBannerSection* sub);

  // optional float remaining_step_distance = 1;
  bool has_remaining_step_distance() const;
  void clear_remaining_step_distance();
  static const int kRemainingStepDistanceFieldNumber = 1;
  float remaining_step_distance() const;
  void set_remaining_step_distance(float value);

  // optional bool used = 5;
  bool has_used() const;
  void clear_used();
  static const int kUsedFieldNumber = 5;
  bool used() const;
  void set_used(bool value);

  // @@protoc_insertion_point(class_scope:navigator.DirectionsBannerInstruction)
 private:
  void set_has_remaining_step_distance();
  void clear_has_remaining_step_distance();
  void set_has_primary();
  void clear_has_primary();
  void set_has_secondary();
  void clear_has_secondary();
  void set_has_sub();
  void clear_has_sub();
  void set_has_used();
  void clear_has_used();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::navigator::DirectionsBannerSection* primary_;
  ::navigator::DirectionsBannerSection* secondary_;
  ::navigator::DirectionsBannerSection* sub_;
  float remaining_step_distance_;
  bool used_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsBannerInstructionImpl();
};
// -------------------------------------------------------------------

class DirectionsVoiceInstruction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.DirectionsVoiceInstruction) */ {
 public:
  DirectionsVoiceInstruction();
  virtual ~DirectionsVoiceInstruction();

  DirectionsVoiceInstruction(const DirectionsVoiceInstruction& from);

  inline DirectionsVoiceInstruction& operator=(const DirectionsVoiceInstruction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectionsVoiceInstruction(DirectionsVoiceInstruction&& from) noexcept
    : DirectionsVoiceInstruction() {
    *this = ::std::move(from);
  }

  inline DirectionsVoiceInstruction& operator=(DirectionsVoiceInstruction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectionsVoiceInstruction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectionsVoiceInstruction* internal_default_instance() {
    return reinterpret_cast<const DirectionsVoiceInstruction*>(
               &_DirectionsVoiceInstruction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(DirectionsVoiceInstruction* other);
  friend void swap(DirectionsVoiceInstruction& a, DirectionsVoiceInstruction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectionsVoiceInstruction* New() const PROTOBUF_FINAL { return New(NULL); }

  DirectionsVoiceInstruction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DirectionsVoiceInstruction& from);
  void MergeFrom(const DirectionsVoiceInstruction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DirectionsVoiceInstruction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string announcement = 2;
  bool has_announcement() const;
  void clear_announcement();
  static const int kAnnouncementFieldNumber = 2;
  const ::std::string& announcement() const;
  void set_announcement(const ::std::string& value);
  #if LANG_CXX11
  void set_announcement(::std::string&& value);
  #endif
  void set_announcement(const char* value);
  void set_announcement(const char* value, size_t size);
  ::std::string* mutable_announcement();
  ::std::string* release_announcement();
  void set_allocated_announcement(::std::string* announcement);

  // optional string ssml_announcement = 3;
  bool has_ssml_announcement() const;
  void clear_ssml_announcement();
  static const int kSsmlAnnouncementFieldNumber = 3;
  const ::std::string& ssml_announcement() const;
  void set_ssml_announcement(const ::std::string& value);
  #if LANG_CXX11
  void set_ssml_announcement(::std::string&& value);
  #endif
  void set_ssml_announcement(const char* value);
  void set_ssml_announcement(const char* value, size_t size);
  ::std::string* mutable_ssml_announcement();
  ::std::string* release_ssml_announcement();
  void set_allocated_ssml_announcement(::std::string* ssml_announcement);

  // optional float remaining_step_distance = 1;
  bool has_remaining_step_distance() const;
  void clear_remaining_step_distance();
  static const int kRemainingStepDistanceFieldNumber = 1;
  float remaining_step_distance() const;
  void set_remaining_step_distance(float value);

  // optional bool used = 4;
  bool has_used() const;
  void clear_used();
  static const int kUsedFieldNumber = 4;
  bool used() const;
  void set_used(bool value);

  // @@protoc_insertion_point(class_scope:navigator.DirectionsVoiceInstruction)
 private:
  void set_has_remaining_step_distance();
  void clear_has_remaining_step_distance();
  void set_has_announcement();
  void clear_has_announcement();
  void set_has_ssml_announcement();
  void clear_has_ssml_announcement();
  void set_has_used();
  void clear_has_used();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr announcement_;
  ::google::protobuf::internal::ArenaStringPtr ssml_announcement_;
  float remaining_step_distance_;
  bool used_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsVoiceInstructionImpl();
};
// -------------------------------------------------------------------

class DirectionsLane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.DirectionsLane) */ {
 public:
  DirectionsLane();
  virtual ~DirectionsLane();

  DirectionsLane(const DirectionsLane& from);

  inline DirectionsLane& operator=(const DirectionsLane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectionsLane(DirectionsLane&& from) noexcept
    : DirectionsLane() {
    *this = ::std::move(from);
  }

  inline DirectionsLane& operator=(DirectionsLane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectionsLane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectionsLane* internal_default_instance() {
    return reinterpret_cast<const DirectionsLane*>(
               &_DirectionsLane_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(DirectionsLane* other);
  friend void swap(DirectionsLane& a, DirectionsLane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectionsLane* New() const PROTOBUF_FINAL { return New(NULL); }

  DirectionsLane* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DirectionsLane& from);
  void MergeFrom(const DirectionsLane& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DirectionsLane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string indications = 2;
  int indications_size() const;
  void clear_indications();
  static const int kIndicationsFieldNumber = 2;
  const ::std::string& indications(int index) const;
  ::std::string* mutable_indications(int index);
  void set_indications(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_indications(int index, ::std::string&& value);
  #endif
  void set_indications(int index, const char* value);
  void set_indications(int index, const char* value, size_t size);
  ::std::string* add_indications();
  void add_indications(const ::std::string& value);
  #if LANG_CXX11
  void add_indications(::std::string&& value);
  #endif
  void add_indications(const char* value);
  void add_indications(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& indications() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_indications();

  // optional bool valid = 1;
  bool has_valid() const;
  void clear_valid();
  static const int kValidFieldNumber = 1;
  bool valid() const;
  void set_valid(bool value);

  // @@protoc_insertion_point(class_scope:navigator.DirectionsLane)
 private:
  void set_has_valid();
  void clear_has_valid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> indications_;
  bool valid_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsLaneImpl();
};
// -------------------------------------------------------------------

class DirectionsIntersection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.DirectionsIntersection) */ {
 public:
  DirectionsIntersection();
  virtual ~DirectionsIntersection();

  DirectionsIntersection(const DirectionsIntersection& from);

  inline DirectionsIntersection& operator=(const DirectionsIntersection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectionsIntersection(DirectionsIntersection&& from) noexcept
    : DirectionsIntersection() {
    *this = ::std::move(from);
  }

  inline DirectionsIntersection& operator=(DirectionsIntersection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectionsIntersection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectionsIntersection* internal_default_instance() {
    return reinterpret_cast<const DirectionsIntersection*>(
               &_DirectionsIntersection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(DirectionsIntersection* other);
  friend void swap(DirectionsIntersection& a, DirectionsIntersection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectionsIntersection* New() const PROTOBUF_FINAL { return New(NULL); }

  DirectionsIntersection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DirectionsIntersection& from);
  void MergeFrom(const DirectionsIntersection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DirectionsIntersection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DirectionsIntersection_Class Class;
  static const Class _ =
    DirectionsIntersection_Class__;
  static const Class toll =
    DirectionsIntersection_Class_toll;
  static const Class ferry =
    DirectionsIntersection_Class_ferry;
  static const Class restricted =
    DirectionsIntersection_Class_restricted;
  static const Class motorway =
    DirectionsIntersection_Class_motorway;
  static const Class tunnel =
    DirectionsIntersection_Class_tunnel;
  static inline bool Class_IsValid(int value) {
    return DirectionsIntersection_Class_IsValid(value);
  }
  static const Class Class_MIN =
    DirectionsIntersection_Class_Class_MIN;
  static const Class Class_MAX =
    DirectionsIntersection_Class_Class_MAX;
  static const int Class_ARRAYSIZE =
    DirectionsIntersection_Class_Class_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Class_descriptor() {
    return DirectionsIntersection_Class_descriptor();
  }
  static inline const ::std::string& Class_Name(Class value) {
    return DirectionsIntersection_Class_Name(value);
  }
  static inline bool Class_Parse(const ::std::string& name,
      Class* value) {
    return DirectionsIntersection_Class_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated double bearings = 2;
  int bearings_size() const;
  void clear_bearings();
  static const int kBearingsFieldNumber = 2;
  double bearings(int index) const;
  void set_bearings(int index, double value);
  void add_bearings(double value);
  const ::google::protobuf::RepeatedField< double >&
      bearings() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_bearings();

  // repeated .navigator.DirectionsIntersection.Class classes = 3;
  int classes_size() const;
  void clear_classes();
  static const int kClassesFieldNumber = 3;
  ::navigator::DirectionsIntersection_Class classes(int index) const;
  void set_classes(int index, ::navigator::DirectionsIntersection_Class value);
  void add_classes(::navigator::DirectionsIntersection_Class value);
  const ::google::protobuf::RepeatedField<int>& classes() const;
  ::google::protobuf::RepeatedField<int>* mutable_classes();

  // repeated bool entries = 4;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 4;
  bool entries(int index) const;
  void set_entries(int index, bool value);
  void add_entries(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      entries() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_entries();

  // repeated .navigator.DirectionsLane lanes = 7;
  int lanes_size() const;
  void clear_lanes();
  static const int kLanesFieldNumber = 7;
  const ::navigator::DirectionsLane& lanes(int index) const;
  ::navigator::DirectionsLane* mutable_lanes(int index);
  ::navigator::DirectionsLane* add_lanes();
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLane >*
      mutable_lanes();
  const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLane >&
      lanes() const;

  // optional uint32 shape_index = 1;
  bool has_shape_index() const;
  void clear_shape_index();
  static const int kShapeIndexFieldNumber = 1;
  ::google::protobuf::uint32 shape_index() const;
  void set_shape_index(::google::protobuf::uint32 value);

  // optional uint32 in = 5;
  bool has_in() const;
  void clear_in();
  static const int kInFieldNumber = 5;
  ::google::protobuf::uint32 in() const;
  void set_in(::google::protobuf::uint32 value);

  // optional uint32 out = 6;
  bool has_out() const;
  void clear_out();
  static const int kOutFieldNumber = 6;
  ::google::protobuf::uint32 out() const;
  void set_out(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:navigator.DirectionsIntersection)
 private:
  void set_has_shape_index();
  void clear_has_shape_index();
  void set_has_in();
  void clear_has_in();
  void set_has_out();
  void clear_has_out();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > bearings_;
  ::google::protobuf::RepeatedField<int> classes_;
  ::google::protobuf::RepeatedField< bool > entries_;
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLane > lanes_;
  ::google::protobuf::uint32 shape_index_;
  ::google::protobuf::uint32 in_;
  ::google::protobuf::uint32 out_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsIntersectionImpl();
};
// -------------------------------------------------------------------

class DirectionsStreetName : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.DirectionsStreetName) */ {
 public:
  DirectionsStreetName();
  virtual ~DirectionsStreetName();

  DirectionsStreetName(const DirectionsStreetName& from);

  inline DirectionsStreetName& operator=(const DirectionsStreetName& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectionsStreetName(DirectionsStreetName&& from) noexcept
    : DirectionsStreetName() {
    *this = ::std::move(from);
  }

  inline DirectionsStreetName& operator=(DirectionsStreetName&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectionsStreetName& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectionsStreetName* internal_default_instance() {
    return reinterpret_cast<const DirectionsStreetName*>(
               &_DirectionsStreetName_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(DirectionsStreetName* other);
  friend void swap(DirectionsStreetName& a, DirectionsStreetName& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectionsStreetName* New() const PROTOBUF_FINAL { return New(NULL); }

  DirectionsStreetName* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DirectionsStreetName& from);
  void MergeFrom(const DirectionsStreetName& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DirectionsStreetName* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:navigator.DirectionsStreetName)
 private:
  void set_has_text();
  void clear_has_text();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsStreetNameImpl();
};
// -------------------------------------------------------------------

class DirectionsManeuver : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.DirectionsManeuver) */ {
 public:
  DirectionsManeuver();
  virtual ~DirectionsManeuver();

  DirectionsManeuver(const DirectionsManeuver& from);

  inline DirectionsManeuver& operator=(const DirectionsManeuver& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectionsManeuver(DirectionsManeuver&& from) noexcept
    : DirectionsManeuver() {
    *this = ::std::move(from);
  }

  inline DirectionsManeuver& operator=(DirectionsManeuver&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectionsManeuver& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectionsManeuver* internal_default_instance() {
    return reinterpret_cast<const DirectionsManeuver*>(
               &_DirectionsManeuver_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(DirectionsManeuver* other);
  friend void swap(DirectionsManeuver& a, DirectionsManeuver& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectionsManeuver* New() const PROTOBUF_FINAL { return New(NULL); }

  DirectionsManeuver* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DirectionsManeuver& from);
  void MergeFrom(const DirectionsManeuver& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DirectionsManeuver* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .navigator.DirectionsStreetName street_names = 7;
  int street_names_size() const;
  void clear_street_names();
  static const int kStreetNamesFieldNumber = 7;
  const ::navigator::DirectionsStreetName& street_names(int index) const;
  ::navigator::DirectionsStreetName* mutable_street_names(int index);
  ::navigator::DirectionsStreetName* add_street_names();
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStreetName >*
      mutable_street_names();
  const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStreetName >&
      street_names() const;

  // optional string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string modifier = 2;
  bool has_modifier() const;
  void clear_modifier();
  static const int kModifierFieldNumber = 2;
  const ::std::string& modifier() const;
  void set_modifier(const ::std::string& value);
  #if LANG_CXX11
  void set_modifier(::std::string&& value);
  #endif
  void set_modifier(const char* value);
  void set_modifier(const char* value, size_t size);
  ::std::string* mutable_modifier();
  ::std::string* release_modifier();
  void set_allocated_modifier(::std::string* modifier);

  // optional string instruction = 3;
  bool has_instruction() const;
  void clear_instruction();
  static const int kInstructionFieldNumber = 3;
  const ::std::string& instruction() const;
  void set_instruction(const ::std::string& value);
  #if LANG_CXX11
  void set_instruction(::std::string&& value);
  #endif
  void set_instruction(const char* value);
  void set_instruction(const char* value, size_t size);
  ::std::string* mutable_instruction();
  ::std::string* release_instruction();
  void set_allocated_instruction(::std::string* instruction);

  // optional uint32 bearing_before = 4;
  bool has_bearing_before() const;
  void clear_bearing_before();
  static const int kBearingBeforeFieldNumber = 4;
  ::google::protobuf::uint32 bearing_before() const;
  void set_bearing_before(::google::protobuf::uint32 value);

  // optional uint32 bearing_after = 5;
  bool has_bearing_after() const;
  void clear_bearing_after();
  static const int kBearingAfterFieldNumber = 5;
  ::google::protobuf::uint32 bearing_after() const;
  void set_bearing_after(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:navigator.DirectionsManeuver)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_modifier();
  void clear_has_modifier();
  void set_has_instruction();
  void clear_has_instruction();
  void set_has_bearing_before();
  void clear_has_bearing_before();
  void set_has_bearing_after();
  void clear_has_bearing_after();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStreetName > street_names_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr modifier_;
  ::google::protobuf::internal::ArenaStringPtr instruction_;
  ::google::protobuf::uint32 bearing_before_;
  ::google::protobuf::uint32 bearing_after_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsManeuverImpl();
};
// -------------------------------------------------------------------

class DirectionsStep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.DirectionsStep) */ {
 public:
  DirectionsStep();
  virtual ~DirectionsStep();

  DirectionsStep(const DirectionsStep& from);

  inline DirectionsStep& operator=(const DirectionsStep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectionsStep(DirectionsStep&& from) noexcept
    : DirectionsStep() {
    *this = ::std::move(from);
  }

  inline DirectionsStep& operator=(DirectionsStep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectionsStep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectionsStep* internal_default_instance() {
    return reinterpret_cast<const DirectionsStep*>(
               &_DirectionsStep_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(DirectionsStep* other);
  friend void swap(DirectionsStep& a, DirectionsStep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectionsStep* New() const PROTOBUF_FINAL { return New(NULL); }

  DirectionsStep* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DirectionsStep& from);
  void MergeFrom(const DirectionsStep& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DirectionsStep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .navigator.DirectionsVoiceInstruction voice_instructions = 4;
  int voice_instructions_size() const;
  void clear_voice_instructions();
  static const int kVoiceInstructionsFieldNumber = 4;
  const ::navigator::DirectionsVoiceInstruction& voice_instructions(int index) const;
  ::navigator::DirectionsVoiceInstruction* mutable_voice_instructions(int index);
  ::navigator::DirectionsVoiceInstruction* add_voice_instructions();
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsVoiceInstruction >*
      mutable_voice_instructions();
  const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsVoiceInstruction >&
      voice_instructions() const;

  // repeated .navigator.DirectionsBannerInstruction banner_instructions = 5;
  int banner_instructions_size() const;
  void clear_banner_instructions();
  static const int kBannerInstructionsFieldNumber = 5;
  const ::navigator::DirectionsBannerInstruction& banner_instructions(int index) const;
  ::navigator::DirectionsBannerInstruction* mutable_banner_instructions(int index);
  ::navigator::DirectionsBannerInstruction* add_banner_instructions();
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsBannerInstruction >*
      mutable_banner_instructions();
  const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsBannerInstruction >&
      banner_instructions() const;

  // repeated .navigator.DirectionsStreetName street_names = 6;
  int street_names_size() const;
  void clear_street_names();
  static const int kStreetNamesFieldNumber = 6;
  const ::navigator::DirectionsStreetName& street_names(int index) const;
  ::navigator::DirectionsStreetName* mutable_street_names(int index);
  ::navigator::DirectionsStreetName* add_street_names();
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStreetName >*
      mutable_street_names();
  const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStreetName >&
      street_names() const;

  // repeated .navigator.DirectionsIntersection intersections = 11;
  int intersections_size() const;
  void clear_intersections();
  static const int kIntersectionsFieldNumber = 11;
  const ::navigator::DirectionsIntersection& intersections(int index) const;
  ::navigator::DirectionsIntersection* mutable_intersections(int index);
  ::navigator::DirectionsIntersection* add_intersections();
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsIntersection >*
      mutable_intersections();
  const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsIntersection >&
      intersections() const;

  // optional string travel_mode = 9;
  bool has_travel_mode() const;
  void clear_travel_mode();
  static const int kTravelModeFieldNumber = 9;
  const ::std::string& travel_mode() const;
  void set_travel_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_travel_mode(::std::string&& value);
  #endif
  void set_travel_mode(const char* value);
  void set_travel_mode(const char* value, size_t size);
  ::std::string* mutable_travel_mode();
  ::std::string* release_travel_mode();
  void set_allocated_travel_mode(::std::string* travel_mode);

  // optional string travel_type = 10;
  bool has_travel_type() const;
  void clear_travel_type();
  static const int kTravelTypeFieldNumber = 10;
  const ::std::string& travel_type() const;
  void set_travel_type(const ::std::string& value);
  #if LANG_CXX11
  void set_travel_type(::std::string&& value);
  #endif
  void set_travel_type(const char* value);
  void set_travel_type(const char* value, size_t size);
  ::std::string* mutable_travel_type();
  ::std::string* release_travel_type();
  void set_allocated_travel_type(::std::string* travel_type);

  // optional string driving_side = 12;
  bool has_driving_side() const;
  void clear_driving_side();
  static const int kDrivingSideFieldNumber = 12;
  const ::std::string& driving_side() const;
  void set_driving_side(const ::std::string& value);
  #if LANG_CXX11
  void set_driving_side(::std::string&& value);
  #endif
  void set_driving_side(const char* value);
  void set_driving_side(const char* value, size_t size);
  ::std::string* mutable_driving_side();
  ::std::string* release_driving_side();
  void set_allocated_driving_side(::std::string* driving_side);

  // optional .navigator.DirectionsManeuver maneuver = 1;
  bool has_maneuver() const;
  void clear_maneuver();
  static const int kManeuverFieldNumber = 1;
  const ::navigator::DirectionsManeuver& maneuver() const;
  ::navigator::DirectionsManeuver* release_maneuver();
  ::navigator::DirectionsManeuver* mutable_maneuver();
  void set_allocated_maneuver(::navigator::DirectionsManeuver* maneuver);

  // optional float distance = 2;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  float distance() const;
  void set_distance(float value);

  // optional uint32 duration = 3;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 3;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // optional uint32 begin_shape_index = 7;
  bool has_begin_shape_index() const;
  void clear_begin_shape_index();
  static const int kBeginShapeIndexFieldNumber = 7;
  ::google::protobuf::uint32 begin_shape_index() const;
  void set_begin_shape_index(::google::protobuf::uint32 value);

  // optional uint32 end_shape_index = 8;
  bool has_end_shape_index() const;
  void clear_end_shape_index();
  static const int kEndShapeIndexFieldNumber = 8;
  ::google::protobuf::uint32 end_shape_index() const;
  void set_end_shape_index(::google::protobuf::uint32 value);

  // optional bool toll = 13;
  bool has_toll() const;
  void clear_toll();
  static const int kTollFieldNumber = 13;
  bool toll() const;
  void set_toll(bool value);

  // optional bool rough = 14;
  bool has_rough() const;
  void clear_rough();
  static const int kRoughFieldNumber = 14;
  bool rough() const;
  void set_rough(bool value);

  // @@protoc_insertion_point(class_scope:navigator.DirectionsStep)
 private:
  void set_has_maneuver();
  void clear_has_maneuver();
  void set_has_distance();
  void clear_has_distance();
  void set_has_duration();
  void clear_has_duration();
  void set_has_begin_shape_index();
  void clear_has_begin_shape_index();
  void set_has_end_shape_index();
  void clear_has_end_shape_index();
  void set_has_travel_mode();
  void clear_has_travel_mode();
  void set_has_travel_type();
  void clear_has_travel_type();
  void set_has_driving_side();
  void clear_has_driving_side();
  void set_has_toll();
  void clear_has_toll();
  void set_has_rough();
  void clear_has_rough();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsVoiceInstruction > voice_instructions_;
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsBannerInstruction > banner_instructions_;
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStreetName > street_names_;
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsIntersection > intersections_;
  ::google::protobuf::internal::ArenaStringPtr travel_mode_;
  ::google::protobuf::internal::ArenaStringPtr travel_type_;
  ::google::protobuf::internal::ArenaStringPtr driving_side_;
  ::navigator::DirectionsManeuver* maneuver_;
  float distance_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::uint32 begin_shape_index_;
  ::google::protobuf::uint32 end_shape_index_;
  bool toll_;
  bool rough_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsStepImpl();
};
// -------------------------------------------------------------------

class DirectionsLeg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.DirectionsLeg) */ {
 public:
  DirectionsLeg();
  virtual ~DirectionsLeg();

  DirectionsLeg(const DirectionsLeg& from);

  inline DirectionsLeg& operator=(const DirectionsLeg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectionsLeg(DirectionsLeg&& from) noexcept
    : DirectionsLeg() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg& operator=(DirectionsLeg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectionsLeg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectionsLeg* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg*>(
               &_DirectionsLeg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(DirectionsLeg* other);
  friend void swap(DirectionsLeg& a, DirectionsLeg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectionsLeg* New() const PROTOBUF_FINAL { return New(NULL); }

  DirectionsLeg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DirectionsLeg& from);
  void MergeFrom(const DirectionsLeg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DirectionsLeg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .navigator.DirectionsStep steps = 2;
  int steps_size() const;
  void clear_steps();
  static const int kStepsFieldNumber = 2;
  const ::navigator::DirectionsStep& steps(int index) const;
  ::navigator::DirectionsStep* mutable_steps(int index);
  ::navigator::DirectionsStep* add_steps();
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStep >*
      mutable_steps();
  const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStep >&
      steps() const;

  // optional string shape = 3;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 3;
  const ::std::string& shape() const;
  void set_shape(const ::std::string& value);
  #if LANG_CXX11
  void set_shape(::std::string&& value);
  #endif
  void set_shape(const char* value);
  void set_shape(const char* value, size_t size);
  ::std::string* mutable_shape();
  ::std::string* release_shape();
  void set_allocated_shape(::std::string* shape);

  // optional .navigator.DirectionsSummary summary = 1;
  bool has_summary() const;
  void clear_summary();
  static const int kSummaryFieldNumber = 1;
  const ::navigator::DirectionsSummary& summary() const;
  ::navigator::DirectionsSummary* release_summary();
  ::navigator::DirectionsSummary* mutable_summary();
  void set_allocated_summary(::navigator::DirectionsSummary* summary);

  // @@protoc_insertion_point(class_scope:navigator.DirectionsLeg)
 private:
  void set_has_summary();
  void clear_has_summary();
  void set_has_shape();
  void clear_has_shape();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStep > steps_;
  ::google::protobuf::internal::ArenaStringPtr shape_;
  ::navigator::DirectionsSummary* summary_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsLegImpl();
};
// -------------------------------------------------------------------

class DirectionsRoute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.DirectionsRoute) */ {
 public:
  DirectionsRoute();
  virtual ~DirectionsRoute();

  DirectionsRoute(const DirectionsRoute& from);

  inline DirectionsRoute& operator=(const DirectionsRoute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectionsRoute(DirectionsRoute&& from) noexcept
    : DirectionsRoute() {
    *this = ::std::move(from);
  }

  inline DirectionsRoute& operator=(DirectionsRoute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectionsRoute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectionsRoute* internal_default_instance() {
    return reinterpret_cast<const DirectionsRoute*>(
               &_DirectionsRoute_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(DirectionsRoute* other);
  friend void swap(DirectionsRoute& a, DirectionsRoute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectionsRoute* New() const PROTOBUF_FINAL { return New(NULL); }

  DirectionsRoute* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DirectionsRoute& from);
  void MergeFrom(const DirectionsRoute& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DirectionsRoute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .navigator.DirectionsLeg legs = 2;
  int legs_size() const;
  void clear_legs();
  static const int kLegsFieldNumber = 2;
  const ::navigator::DirectionsLeg& legs(int index) const;
  ::navigator::DirectionsLeg* mutable_legs(int index);
  ::navigator::DirectionsLeg* add_legs();
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLeg >*
      mutable_legs();
  const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLeg >&
      legs() const;

  // optional string voice_locale = 3;
  bool has_voice_locale() const;
  void clear_voice_locale();
  static const int kVoiceLocaleFieldNumber = 3;
  const ::std::string& voice_locale() const;
  void set_voice_locale(const ::std::string& value);
  #if LANG_CXX11
  void set_voice_locale(::std::string&& value);
  #endif
  void set_voice_locale(const char* value);
  void set_voice_locale(const char* value, size_t size);
  ::std::string* mutable_voice_locale();
  ::std::string* release_voice_locale();
  void set_allocated_voice_locale(::std::string* voice_locale);

  // optional .navigator.DirectionsSummary summary = 1;
  bool has_summary() const;
  void clear_summary();
  static const int kSummaryFieldNumber = 1;
  const ::navigator::DirectionsSummary& summary() const;
  ::navigator::DirectionsSummary* release_summary();
  ::navigator::DirectionsSummary* mutable_summary();
  void set_allocated_summary(::navigator::DirectionsSummary* summary);

  // @@protoc_insertion_point(class_scope:navigator.DirectionsRoute)
 private:
  void set_has_summary();
  void clear_has_summary();
  void set_has_voice_locale();
  void clear_has_voice_locale();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLeg > legs_;
  ::google::protobuf::internal::ArenaStringPtr voice_locale_;
  ::navigator::DirectionsSummary* summary_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsRouteImpl();
};
// -------------------------------------------------------------------

class Directions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:navigator.Directions) */ {
 public:
  Directions();
  virtual ~Directions();

  Directions(const Directions& from);

  inline Directions& operator=(const Directions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Directions(Directions&& from) noexcept
    : Directions() {
    *this = ::std::move(from);
  }

  inline Directions& operator=(Directions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Directions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Directions* internal_default_instance() {
    return reinterpret_cast<const Directions*>(
               &_Directions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Directions* other);
  friend void swap(Directions& a, Directions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Directions* New() const PROTOBUF_FINAL { return New(NULL); }

  Directions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Directions& from);
  void MergeFrom(const Directions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Directions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .navigator.DirectionsLocation locations = 1;
  int locations_size() const;
  void clear_locations();
  static const int kLocationsFieldNumber = 1;
  const ::navigator::DirectionsLocation& locations(int index) const;
  ::navigator::DirectionsLocation* mutable_locations(int index);
  ::navigator::DirectionsLocation* add_locations();
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLocation >*
      mutable_locations();
  const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLocation >&
      locations() const;

  // repeated .navigator.DirectionsRoute routes = 2;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 2;
  const ::navigator::DirectionsRoute& routes(int index) const;
  ::navigator::DirectionsRoute* mutable_routes(int index);
  ::navigator::DirectionsRoute* add_routes();
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsRoute >*
      mutable_routes();
  const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsRoute >&
      routes() const;

  // optional string code = 4;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 4;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // optional string uuid = 5;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 5;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // optional .navigator.DirectionsBoundingBox bounding_box = 3;
  bool has_bounding_box() const;
  void clear_bounding_box();
  static const int kBoundingBoxFieldNumber = 3;
  const ::navigator::DirectionsBoundingBox& bounding_box() const;
  ::navigator::DirectionsBoundingBox* release_bounding_box();
  ::navigator::DirectionsBoundingBox* mutable_bounding_box();
  void set_allocated_bounding_box(::navigator::DirectionsBoundingBox* bounding_box);

  // @@protoc_insertion_point(class_scope:navigator.Directions)
 private:
  void set_has_bounding_box();
  void clear_has_bounding_box();
  void set_has_code();
  void clear_has_code();
  void set_has_uuid();
  void clear_has_uuid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLocation > locations_;
  ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsRoute > routes_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::navigator::DirectionsBoundingBox* bounding_box_;
  friend struct ::protobuf_directions_2eproto::TableStruct;
  friend void ::protobuf_directions_2eproto::InitDefaultsDirectionsImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DirectionsLocation

// optional float lat = 1;
inline bool DirectionsLocation::has_lat() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DirectionsLocation::set_has_lat() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DirectionsLocation::clear_has_lat() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DirectionsLocation::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float DirectionsLocation::lat() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLocation.lat)
  return lat_;
}
inline void DirectionsLocation::set_lat(float value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsLocation.lat)
}

// optional float lon = 2;
inline bool DirectionsLocation::has_lon() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DirectionsLocation::set_has_lon() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DirectionsLocation::clear_has_lon() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DirectionsLocation::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float DirectionsLocation::lon() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLocation.lon)
  return lon_;
}
inline void DirectionsLocation::set_lon(float value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsLocation.lon)
}

// optional string type = 3;
inline bool DirectionsLocation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsLocation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsLocation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsLocation::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& DirectionsLocation::type() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLocation.type)
  return type_.GetNoArena();
}
inline void DirectionsLocation::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsLocation.type)
}
#if LANG_CXX11
inline void DirectionsLocation::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsLocation.type)
}
#endif
inline void DirectionsLocation::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsLocation.type)
}
inline void DirectionsLocation::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsLocation.type)
}
inline ::std::string* DirectionsLocation::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsLocation.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLocation::release_type() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsLocation.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsLocation::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsLocation.type)
}

// optional uint32 bearing = 4;
inline bool DirectionsLocation::has_bearing() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DirectionsLocation::set_has_bearing() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DirectionsLocation::clear_has_bearing() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DirectionsLocation::clear_bearing() {
  bearing_ = 0u;
  clear_has_bearing();
}
inline ::google::protobuf::uint32 DirectionsLocation::bearing() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLocation.bearing)
  return bearing_;
}
inline void DirectionsLocation::set_bearing(::google::protobuf::uint32 value) {
  set_has_bearing();
  bearing_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsLocation.bearing)
}

// optional string name = 5;
inline bool DirectionsLocation::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsLocation::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsLocation::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsLocation::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DirectionsLocation::name() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLocation.name)
  return name_.GetNoArena();
}
inline void DirectionsLocation::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsLocation.name)
}
#if LANG_CXX11
inline void DirectionsLocation::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsLocation.name)
}
#endif
inline void DirectionsLocation::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsLocation.name)
}
inline void DirectionsLocation::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsLocation.name)
}
inline ::std::string* DirectionsLocation::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsLocation.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLocation::release_name() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsLocation.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsLocation::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsLocation.name)
}

// optional string street = 6;
inline bool DirectionsLocation::has_street() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectionsLocation::set_has_street() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectionsLocation::clear_has_street() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectionsLocation::clear_street() {
  street_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_street();
}
inline const ::std::string& DirectionsLocation::street() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLocation.street)
  return street_.GetNoArena();
}
inline void DirectionsLocation::set_street(const ::std::string& value) {
  set_has_street();
  street_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsLocation.street)
}
#if LANG_CXX11
inline void DirectionsLocation::set_street(::std::string&& value) {
  set_has_street();
  street_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsLocation.street)
}
#endif
inline void DirectionsLocation::set_street(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_street();
  street_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsLocation.street)
}
inline void DirectionsLocation::set_street(const char* value, size_t size) {
  set_has_street();
  street_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsLocation.street)
}
inline ::std::string* DirectionsLocation::mutable_street() {
  set_has_street();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsLocation.street)
  return street_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLocation::release_street() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsLocation.street)
  clear_has_street();
  return street_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsLocation::set_allocated_street(::std::string* street) {
  if (street != NULL) {
    set_has_street();
  } else {
    clear_has_street();
  }
  street_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), street);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsLocation.street)
}

// optional string city = 7;
inline bool DirectionsLocation::has_city() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectionsLocation::set_has_city() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectionsLocation::clear_has_city() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectionsLocation::clear_city() {
  city_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_city();
}
inline const ::std::string& DirectionsLocation::city() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLocation.city)
  return city_.GetNoArena();
}
inline void DirectionsLocation::set_city(const ::std::string& value) {
  set_has_city();
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsLocation.city)
}
#if LANG_CXX11
inline void DirectionsLocation::set_city(::std::string&& value) {
  set_has_city();
  city_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsLocation.city)
}
#endif
inline void DirectionsLocation::set_city(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_city();
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsLocation.city)
}
inline void DirectionsLocation::set_city(const char* value, size_t size) {
  set_has_city();
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsLocation.city)
}
inline ::std::string* DirectionsLocation::mutable_city() {
  set_has_city();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsLocation.city)
  return city_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLocation::release_city() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsLocation.city)
  clear_has_city();
  return city_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsLocation::set_allocated_city(::std::string* city) {
  if (city != NULL) {
    set_has_city();
  } else {
    clear_has_city();
  }
  city_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), city);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsLocation.city)
}

// optional string state = 8;
inline bool DirectionsLocation::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DirectionsLocation::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DirectionsLocation::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DirectionsLocation::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_state();
}
inline const ::std::string& DirectionsLocation::state() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLocation.state)
  return state_.GetNoArena();
}
inline void DirectionsLocation::set_state(const ::std::string& value) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsLocation.state)
}
#if LANG_CXX11
inline void DirectionsLocation::set_state(::std::string&& value) {
  set_has_state();
  state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsLocation.state)
}
#endif
inline void DirectionsLocation::set_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsLocation.state)
}
inline void DirectionsLocation::set_state(const char* value, size_t size) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsLocation.state)
}
inline ::std::string* DirectionsLocation::mutable_state() {
  set_has_state();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsLocation.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLocation::release_state() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsLocation.state)
  clear_has_state();
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsLocation::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    set_has_state();
  } else {
    clear_has_state();
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsLocation.state)
}

// optional string postal_code = 9;
inline bool DirectionsLocation::has_postal_code() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DirectionsLocation::set_has_postal_code() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DirectionsLocation::clear_has_postal_code() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DirectionsLocation::clear_postal_code() {
  postal_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_postal_code();
}
inline const ::std::string& DirectionsLocation::postal_code() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLocation.postal_code)
  return postal_code_.GetNoArena();
}
inline void DirectionsLocation::set_postal_code(const ::std::string& value) {
  set_has_postal_code();
  postal_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsLocation.postal_code)
}
#if LANG_CXX11
inline void DirectionsLocation::set_postal_code(::std::string&& value) {
  set_has_postal_code();
  postal_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsLocation.postal_code)
}
#endif
inline void DirectionsLocation::set_postal_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_postal_code();
  postal_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsLocation.postal_code)
}
inline void DirectionsLocation::set_postal_code(const char* value, size_t size) {
  set_has_postal_code();
  postal_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsLocation.postal_code)
}
inline ::std::string* DirectionsLocation::mutable_postal_code() {
  set_has_postal_code();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsLocation.postal_code)
  return postal_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLocation::release_postal_code() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsLocation.postal_code)
  clear_has_postal_code();
  return postal_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsLocation::set_allocated_postal_code(::std::string* postal_code) {
  if (postal_code != NULL) {
    set_has_postal_code();
  } else {
    clear_has_postal_code();
  }
  postal_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), postal_code);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsLocation.postal_code)
}

// optional string country = 10;
inline bool DirectionsLocation::has_country() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DirectionsLocation::set_has_country() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DirectionsLocation::clear_has_country() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DirectionsLocation::clear_country() {
  country_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_country();
}
inline const ::std::string& DirectionsLocation::country() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLocation.country)
  return country_.GetNoArena();
}
inline void DirectionsLocation::set_country(const ::std::string& value) {
  set_has_country();
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsLocation.country)
}
#if LANG_CXX11
inline void DirectionsLocation::set_country(::std::string&& value) {
  set_has_country();
  country_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsLocation.country)
}
#endif
inline void DirectionsLocation::set_country(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_country();
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsLocation.country)
}
inline void DirectionsLocation::set_country(const char* value, size_t size) {
  set_has_country();
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsLocation.country)
}
inline ::std::string* DirectionsLocation::mutable_country() {
  set_has_country();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsLocation.country)
  return country_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLocation::release_country() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsLocation.country)
  clear_has_country();
  return country_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsLocation::set_allocated_country(::std::string* country) {
  if (country != NULL) {
    set_has_country();
  } else {
    clear_has_country();
  }
  country_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), country);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsLocation.country)
}

// optional string date_time = 11;
inline bool DirectionsLocation::has_date_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DirectionsLocation::set_has_date_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DirectionsLocation::clear_has_date_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DirectionsLocation::clear_date_time() {
  date_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_date_time();
}
inline const ::std::string& DirectionsLocation::date_time() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLocation.date_time)
  return date_time_.GetNoArena();
}
inline void DirectionsLocation::set_date_time(const ::std::string& value) {
  set_has_date_time();
  date_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsLocation.date_time)
}
#if LANG_CXX11
inline void DirectionsLocation::set_date_time(::std::string&& value) {
  set_has_date_time();
  date_time_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsLocation.date_time)
}
#endif
inline void DirectionsLocation::set_date_time(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_date_time();
  date_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsLocation.date_time)
}
inline void DirectionsLocation::set_date_time(const char* value, size_t size) {
  set_has_date_time();
  date_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsLocation.date_time)
}
inline ::std::string* DirectionsLocation::mutable_date_time() {
  set_has_date_time();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsLocation.date_time)
  return date_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLocation::release_date_time() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsLocation.date_time)
  clear_has_date_time();
  return date_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsLocation::set_allocated_date_time(::std::string* date_time) {
  if (date_time != NULL) {
    set_has_date_time();
  } else {
    clear_has_date_time();
  }
  date_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date_time);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsLocation.date_time)
}

// optional string side_of_street = 12;
inline bool DirectionsLocation::has_side_of_street() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DirectionsLocation::set_has_side_of_street() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DirectionsLocation::clear_has_side_of_street() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DirectionsLocation::clear_side_of_street() {
  side_of_street_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_side_of_street();
}
inline const ::std::string& DirectionsLocation::side_of_street() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLocation.side_of_street)
  return side_of_street_.GetNoArena();
}
inline void DirectionsLocation::set_side_of_street(const ::std::string& value) {
  set_has_side_of_street();
  side_of_street_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsLocation.side_of_street)
}
#if LANG_CXX11
inline void DirectionsLocation::set_side_of_street(::std::string&& value) {
  set_has_side_of_street();
  side_of_street_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsLocation.side_of_street)
}
#endif
inline void DirectionsLocation::set_side_of_street(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_side_of_street();
  side_of_street_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsLocation.side_of_street)
}
inline void DirectionsLocation::set_side_of_street(const char* value, size_t size) {
  set_has_side_of_street();
  side_of_street_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsLocation.side_of_street)
}
inline ::std::string* DirectionsLocation::mutable_side_of_street() {
  set_has_side_of_street();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsLocation.side_of_street)
  return side_of_street_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLocation::release_side_of_street() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsLocation.side_of_street)
  clear_has_side_of_street();
  return side_of_street_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsLocation::set_allocated_side_of_street(::std::string* side_of_street) {
  if (side_of_street != NULL) {
    set_has_side_of_street();
  } else {
    clear_has_side_of_street();
  }
  side_of_street_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), side_of_street);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsLocation.side_of_street)
}

// optional uint32 original_index = 13;
inline bool DirectionsLocation::has_original_index() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DirectionsLocation::set_has_original_index() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DirectionsLocation::clear_has_original_index() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DirectionsLocation::clear_original_index() {
  original_index_ = 0u;
  clear_has_original_index();
}
inline ::google::protobuf::uint32 DirectionsLocation::original_index() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLocation.original_index)
  return original_index_;
}
inline void DirectionsLocation::set_original_index(::google::protobuf::uint32 value) {
  set_has_original_index();
  original_index_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsLocation.original_index)
}

// -------------------------------------------------------------------

// DirectionsBoundingBox

// optional float min_lat = 1;
inline bool DirectionsBoundingBox::has_min_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsBoundingBox::set_has_min_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsBoundingBox::clear_has_min_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsBoundingBox::clear_min_lat() {
  min_lat_ = 0;
  clear_has_min_lat();
}
inline float DirectionsBoundingBox::min_lat() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBoundingBox.min_lat)
  return min_lat_;
}
inline void DirectionsBoundingBox::set_min_lat(float value) {
  set_has_min_lat();
  min_lat_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsBoundingBox.min_lat)
}

// optional float min_lon = 2;
inline bool DirectionsBoundingBox::has_min_lon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsBoundingBox::set_has_min_lon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsBoundingBox::clear_has_min_lon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsBoundingBox::clear_min_lon() {
  min_lon_ = 0;
  clear_has_min_lon();
}
inline float DirectionsBoundingBox::min_lon() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBoundingBox.min_lon)
  return min_lon_;
}
inline void DirectionsBoundingBox::set_min_lon(float value) {
  set_has_min_lon();
  min_lon_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsBoundingBox.min_lon)
}

// optional float max_lat = 3;
inline bool DirectionsBoundingBox::has_max_lat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectionsBoundingBox::set_has_max_lat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectionsBoundingBox::clear_has_max_lat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectionsBoundingBox::clear_max_lat() {
  max_lat_ = 0;
  clear_has_max_lat();
}
inline float DirectionsBoundingBox::max_lat() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBoundingBox.max_lat)
  return max_lat_;
}
inline void DirectionsBoundingBox::set_max_lat(float value) {
  set_has_max_lat();
  max_lat_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsBoundingBox.max_lat)
}

// optional float max_lon = 4;
inline bool DirectionsBoundingBox::has_max_lon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectionsBoundingBox::set_has_max_lon() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectionsBoundingBox::clear_has_max_lon() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectionsBoundingBox::clear_max_lon() {
  max_lon_ = 0;
  clear_has_max_lon();
}
inline float DirectionsBoundingBox::max_lon() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBoundingBox.max_lon)
  return max_lon_;
}
inline void DirectionsBoundingBox::set_max_lon(float value) {
  set_has_max_lon();
  max_lon_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsBoundingBox.max_lon)
}

// -------------------------------------------------------------------

// DirectionsSummary

// optional string text = 1;
inline bool DirectionsSummary::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsSummary::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsSummary::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsSummary::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& DirectionsSummary::text() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsSummary.text)
  return text_.GetNoArena();
}
inline void DirectionsSummary::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsSummary.text)
}
#if LANG_CXX11
inline void DirectionsSummary::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsSummary.text)
}
#endif
inline void DirectionsSummary::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsSummary.text)
}
inline void DirectionsSummary::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsSummary.text)
}
inline ::std::string* DirectionsSummary::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsSummary.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsSummary::release_text() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsSummary.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsSummary::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsSummary.text)
}

// optional float distance = 2;
inline bool DirectionsSummary::has_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectionsSummary::set_has_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectionsSummary::clear_has_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectionsSummary::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float DirectionsSummary::distance() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsSummary.distance)
  return distance_;
}
inline void DirectionsSummary::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsSummary.distance)
}

// optional uint32 duration = 3;
inline bool DirectionsSummary::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectionsSummary::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectionsSummary::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectionsSummary::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 DirectionsSummary::duration() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsSummary.duration)
  return duration_;
}
inline void DirectionsSummary::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsSummary.duration)
}

// optional .navigator.DirectionsBoundingBox bounding_box = 4;
inline bool DirectionsSummary::has_bounding_box() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsSummary::set_has_bounding_box() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsSummary::clear_has_bounding_box() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsSummary::clear_bounding_box() {
  if (bounding_box_ != NULL) bounding_box_->Clear();
  clear_has_bounding_box();
}
inline const ::navigator::DirectionsBoundingBox& DirectionsSummary::bounding_box() const {
  const ::navigator::DirectionsBoundingBox* p = bounding_box_;
  // @@protoc_insertion_point(field_get:navigator.DirectionsSummary.bounding_box)
  return p != NULL ? *p : *reinterpret_cast<const ::navigator::DirectionsBoundingBox*>(
      &::navigator::_DirectionsBoundingBox_default_instance_);
}
inline ::navigator::DirectionsBoundingBox* DirectionsSummary::release_bounding_box() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsSummary.bounding_box)
  clear_has_bounding_box();
  ::navigator::DirectionsBoundingBox* temp = bounding_box_;
  bounding_box_ = NULL;
  return temp;
}
inline ::navigator::DirectionsBoundingBox* DirectionsSummary::mutable_bounding_box() {
  set_has_bounding_box();
  if (bounding_box_ == NULL) {
    bounding_box_ = new ::navigator::DirectionsBoundingBox;
  }
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsSummary.bounding_box)
  return bounding_box_;
}
inline void DirectionsSummary::set_allocated_bounding_box(::navigator::DirectionsBoundingBox* bounding_box) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bounding_box_;
  }
  if (bounding_box) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bounding_box = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bounding_box, submessage_arena);
    }
    set_has_bounding_box();
  } else {
    clear_has_bounding_box();
  }
  bounding_box_ = bounding_box;
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsSummary.bounding_box)
}

// -------------------------------------------------------------------

// DirectionsBannerComponent

// optional string type = 1;
inline bool DirectionsBannerComponent::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsBannerComponent::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsBannerComponent::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsBannerComponent::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& DirectionsBannerComponent::type() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerComponent.type)
  return type_.GetNoArena();
}
inline void DirectionsBannerComponent::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsBannerComponent.type)
}
#if LANG_CXX11
inline void DirectionsBannerComponent::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsBannerComponent.type)
}
#endif
inline void DirectionsBannerComponent::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsBannerComponent.type)
}
inline void DirectionsBannerComponent::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsBannerComponent.type)
}
inline ::std::string* DirectionsBannerComponent::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsBannerComponent.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsBannerComponent::release_type() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsBannerComponent.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsBannerComponent::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsBannerComponent.type)
}

// optional string text = 2;
inline bool DirectionsBannerComponent::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsBannerComponent::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsBannerComponent::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsBannerComponent::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& DirectionsBannerComponent::text() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerComponent.text)
  return text_.GetNoArena();
}
inline void DirectionsBannerComponent::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsBannerComponent.text)
}
#if LANG_CXX11
inline void DirectionsBannerComponent::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsBannerComponent.text)
}
#endif
inline void DirectionsBannerComponent::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsBannerComponent.text)
}
inline void DirectionsBannerComponent::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsBannerComponent.text)
}
inline ::std::string* DirectionsBannerComponent::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsBannerComponent.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsBannerComponent::release_text() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsBannerComponent.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsBannerComponent::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsBannerComponent.text)
}

// optional string abbr = 3;
inline bool DirectionsBannerComponent::has_abbr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectionsBannerComponent::set_has_abbr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectionsBannerComponent::clear_has_abbr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectionsBannerComponent::clear_abbr() {
  abbr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_abbr();
}
inline const ::std::string& DirectionsBannerComponent::abbr() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerComponent.abbr)
  return abbr_.GetNoArena();
}
inline void DirectionsBannerComponent::set_abbr(const ::std::string& value) {
  set_has_abbr();
  abbr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsBannerComponent.abbr)
}
#if LANG_CXX11
inline void DirectionsBannerComponent::set_abbr(::std::string&& value) {
  set_has_abbr();
  abbr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsBannerComponent.abbr)
}
#endif
inline void DirectionsBannerComponent::set_abbr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_abbr();
  abbr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsBannerComponent.abbr)
}
inline void DirectionsBannerComponent::set_abbr(const char* value, size_t size) {
  set_has_abbr();
  abbr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsBannerComponent.abbr)
}
inline ::std::string* DirectionsBannerComponent::mutable_abbr() {
  set_has_abbr();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsBannerComponent.abbr)
  return abbr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsBannerComponent::release_abbr() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsBannerComponent.abbr)
  clear_has_abbr();
  return abbr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsBannerComponent::set_allocated_abbr(::std::string* abbr) {
  if (abbr != NULL) {
    set_has_abbr();
  } else {
    clear_has_abbr();
  }
  abbr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), abbr);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsBannerComponent.abbr)
}

// optional uint32 abbr_priority = 4;
inline bool DirectionsBannerComponent::has_abbr_priority() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DirectionsBannerComponent::set_has_abbr_priority() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DirectionsBannerComponent::clear_has_abbr_priority() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DirectionsBannerComponent::clear_abbr_priority() {
  abbr_priority_ = 0u;
  clear_has_abbr_priority();
}
inline ::google::protobuf::uint32 DirectionsBannerComponent::abbr_priority() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerComponent.abbr_priority)
  return abbr_priority_;
}
inline void DirectionsBannerComponent::set_abbr_priority(::google::protobuf::uint32 value) {
  set_has_abbr_priority();
  abbr_priority_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsBannerComponent.abbr_priority)
}

// optional string image_baseurl = 5;
inline bool DirectionsBannerComponent::has_image_baseurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectionsBannerComponent::set_has_image_baseurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectionsBannerComponent::clear_has_image_baseurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectionsBannerComponent::clear_image_baseurl() {
  image_baseurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_image_baseurl();
}
inline const ::std::string& DirectionsBannerComponent::image_baseurl() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerComponent.image_baseurl)
  return image_baseurl_.GetNoArena();
}
inline void DirectionsBannerComponent::set_image_baseurl(const ::std::string& value) {
  set_has_image_baseurl();
  image_baseurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsBannerComponent.image_baseurl)
}
#if LANG_CXX11
inline void DirectionsBannerComponent::set_image_baseurl(::std::string&& value) {
  set_has_image_baseurl();
  image_baseurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsBannerComponent.image_baseurl)
}
#endif
inline void DirectionsBannerComponent::set_image_baseurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_image_baseurl();
  image_baseurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsBannerComponent.image_baseurl)
}
inline void DirectionsBannerComponent::set_image_baseurl(const char* value, size_t size) {
  set_has_image_baseurl();
  image_baseurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsBannerComponent.image_baseurl)
}
inline ::std::string* DirectionsBannerComponent::mutable_image_baseurl() {
  set_has_image_baseurl();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsBannerComponent.image_baseurl)
  return image_baseurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsBannerComponent::release_image_baseurl() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsBannerComponent.image_baseurl)
  clear_has_image_baseurl();
  return image_baseurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsBannerComponent::set_allocated_image_baseurl(::std::string* image_baseurl) {
  if (image_baseurl != NULL) {
    set_has_image_baseurl();
  } else {
    clear_has_image_baseurl();
  }
  image_baseurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image_baseurl);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsBannerComponent.image_baseurl)
}

// -------------------------------------------------------------------

// DirectionsBannerSection

// optional string text = 1;
inline bool DirectionsBannerSection::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsBannerSection::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsBannerSection::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsBannerSection::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& DirectionsBannerSection::text() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerSection.text)
  return text_.GetNoArena();
}
inline void DirectionsBannerSection::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsBannerSection.text)
}
#if LANG_CXX11
inline void DirectionsBannerSection::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsBannerSection.text)
}
#endif
inline void DirectionsBannerSection::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsBannerSection.text)
}
inline void DirectionsBannerSection::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsBannerSection.text)
}
inline ::std::string* DirectionsBannerSection::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsBannerSection.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsBannerSection::release_text() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsBannerSection.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsBannerSection::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsBannerSection.text)
}

// repeated .navigator.DirectionsBannerComponent components = 2;
inline int DirectionsBannerSection::components_size() const {
  return components_.size();
}
inline void DirectionsBannerSection::clear_components() {
  components_.Clear();
}
inline const ::navigator::DirectionsBannerComponent& DirectionsBannerSection::components(int index) const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerSection.components)
  return components_.Get(index);
}
inline ::navigator::DirectionsBannerComponent* DirectionsBannerSection::mutable_components(int index) {
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsBannerSection.components)
  return components_.Mutable(index);
}
inline ::navigator::DirectionsBannerComponent* DirectionsBannerSection::add_components() {
  // @@protoc_insertion_point(field_add:navigator.DirectionsBannerSection.components)
  return components_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsBannerComponent >*
DirectionsBannerSection::mutable_components() {
  // @@protoc_insertion_point(field_mutable_list:navigator.DirectionsBannerSection.components)
  return &components_;
}
inline const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsBannerComponent >&
DirectionsBannerSection::components() const {
  // @@protoc_insertion_point(field_list:navigator.DirectionsBannerSection.components)
  return components_;
}

// optional string type = 3;
inline bool DirectionsBannerSection::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsBannerSection::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsBannerSection::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsBannerSection::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& DirectionsBannerSection::type() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerSection.type)
  return type_.GetNoArena();
}
inline void DirectionsBannerSection::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsBannerSection.type)
}
#if LANG_CXX11
inline void DirectionsBannerSection::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsBannerSection.type)
}
#endif
inline void DirectionsBannerSection::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsBannerSection.type)
}
inline void DirectionsBannerSection::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsBannerSection.type)
}
inline ::std::string* DirectionsBannerSection::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsBannerSection.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsBannerSection::release_type() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsBannerSection.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsBannerSection::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsBannerSection.type)
}

// optional string modifier = 4;
inline bool DirectionsBannerSection::has_modifier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectionsBannerSection::set_has_modifier() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectionsBannerSection::clear_has_modifier() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectionsBannerSection::clear_modifier() {
  modifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_modifier();
}
inline const ::std::string& DirectionsBannerSection::modifier() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerSection.modifier)
  return modifier_.GetNoArena();
}
inline void DirectionsBannerSection::set_modifier(const ::std::string& value) {
  set_has_modifier();
  modifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsBannerSection.modifier)
}
#if LANG_CXX11
inline void DirectionsBannerSection::set_modifier(::std::string&& value) {
  set_has_modifier();
  modifier_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsBannerSection.modifier)
}
#endif
inline void DirectionsBannerSection::set_modifier(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_modifier();
  modifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsBannerSection.modifier)
}
inline void DirectionsBannerSection::set_modifier(const char* value, size_t size) {
  set_has_modifier();
  modifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsBannerSection.modifier)
}
inline ::std::string* DirectionsBannerSection::mutable_modifier() {
  set_has_modifier();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsBannerSection.modifier)
  return modifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsBannerSection::release_modifier() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsBannerSection.modifier)
  clear_has_modifier();
  return modifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsBannerSection::set_allocated_modifier(::std::string* modifier) {
  if (modifier != NULL) {
    set_has_modifier();
  } else {
    clear_has_modifier();
  }
  modifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modifier);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsBannerSection.modifier)
}

// optional uint32 degrees = 5;
inline bool DirectionsBannerSection::has_degrees() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DirectionsBannerSection::set_has_degrees() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DirectionsBannerSection::clear_has_degrees() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DirectionsBannerSection::clear_degrees() {
  degrees_ = 0u;
  clear_has_degrees();
}
inline ::google::protobuf::uint32 DirectionsBannerSection::degrees() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerSection.degrees)
  return degrees_;
}
inline void DirectionsBannerSection::set_degrees(::google::protobuf::uint32 value) {
  set_has_degrees();
  degrees_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsBannerSection.degrees)
}

// optional string driving_side = 6;
inline bool DirectionsBannerSection::has_driving_side() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectionsBannerSection::set_has_driving_side() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectionsBannerSection::clear_has_driving_side() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectionsBannerSection::clear_driving_side() {
  driving_side_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_driving_side();
}
inline const ::std::string& DirectionsBannerSection::driving_side() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerSection.driving_side)
  return driving_side_.GetNoArena();
}
inline void DirectionsBannerSection::set_driving_side(const ::std::string& value) {
  set_has_driving_side();
  driving_side_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsBannerSection.driving_side)
}
#if LANG_CXX11
inline void DirectionsBannerSection::set_driving_side(::std::string&& value) {
  set_has_driving_side();
  driving_side_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsBannerSection.driving_side)
}
#endif
inline void DirectionsBannerSection::set_driving_side(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_driving_side();
  driving_side_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsBannerSection.driving_side)
}
inline void DirectionsBannerSection::set_driving_side(const char* value, size_t size) {
  set_has_driving_side();
  driving_side_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsBannerSection.driving_side)
}
inline ::std::string* DirectionsBannerSection::mutable_driving_side() {
  set_has_driving_side();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsBannerSection.driving_side)
  return driving_side_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsBannerSection::release_driving_side() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsBannerSection.driving_side)
  clear_has_driving_side();
  return driving_side_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsBannerSection::set_allocated_driving_side(::std::string* driving_side) {
  if (driving_side != NULL) {
    set_has_driving_side();
  } else {
    clear_has_driving_side();
  }
  driving_side_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driving_side);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsBannerSection.driving_side)
}

// -------------------------------------------------------------------

// DirectionsBannerInstruction

// optional float remaining_step_distance = 1;
inline bool DirectionsBannerInstruction::has_remaining_step_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectionsBannerInstruction::set_has_remaining_step_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectionsBannerInstruction::clear_has_remaining_step_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectionsBannerInstruction::clear_remaining_step_distance() {
  remaining_step_distance_ = 0;
  clear_has_remaining_step_distance();
}
inline float DirectionsBannerInstruction::remaining_step_distance() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerInstruction.remaining_step_distance)
  return remaining_step_distance_;
}
inline void DirectionsBannerInstruction::set_remaining_step_distance(float value) {
  set_has_remaining_step_distance();
  remaining_step_distance_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsBannerInstruction.remaining_step_distance)
}

// optional .navigator.DirectionsBannerSection primary = 2;
inline bool DirectionsBannerInstruction::has_primary() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsBannerInstruction::set_has_primary() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsBannerInstruction::clear_has_primary() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsBannerInstruction::clear_primary() {
  if (primary_ != NULL) primary_->Clear();
  clear_has_primary();
}
inline const ::navigator::DirectionsBannerSection& DirectionsBannerInstruction::primary() const {
  const ::navigator::DirectionsBannerSection* p = primary_;
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerInstruction.primary)
  return p != NULL ? *p : *reinterpret_cast<const ::navigator::DirectionsBannerSection*>(
      &::navigator::_DirectionsBannerSection_default_instance_);
}
inline ::navigator::DirectionsBannerSection* DirectionsBannerInstruction::release_primary() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsBannerInstruction.primary)
  clear_has_primary();
  ::navigator::DirectionsBannerSection* temp = primary_;
  primary_ = NULL;
  return temp;
}
inline ::navigator::DirectionsBannerSection* DirectionsBannerInstruction::mutable_primary() {
  set_has_primary();
  if (primary_ == NULL) {
    primary_ = new ::navigator::DirectionsBannerSection;
  }
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsBannerInstruction.primary)
  return primary_;
}
inline void DirectionsBannerInstruction::set_allocated_primary(::navigator::DirectionsBannerSection* primary) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete primary_;
  }
  if (primary) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      primary = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, primary, submessage_arena);
    }
    set_has_primary();
  } else {
    clear_has_primary();
  }
  primary_ = primary;
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsBannerInstruction.primary)
}

// optional .navigator.DirectionsBannerSection secondary = 3;
inline bool DirectionsBannerInstruction::has_secondary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsBannerInstruction::set_has_secondary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsBannerInstruction::clear_has_secondary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsBannerInstruction::clear_secondary() {
  if (secondary_ != NULL) secondary_->Clear();
  clear_has_secondary();
}
inline const ::navigator::DirectionsBannerSection& DirectionsBannerInstruction::secondary() const {
  const ::navigator::DirectionsBannerSection* p = secondary_;
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerInstruction.secondary)
  return p != NULL ? *p : *reinterpret_cast<const ::navigator::DirectionsBannerSection*>(
      &::navigator::_DirectionsBannerSection_default_instance_);
}
inline ::navigator::DirectionsBannerSection* DirectionsBannerInstruction::release_secondary() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsBannerInstruction.secondary)
  clear_has_secondary();
  ::navigator::DirectionsBannerSection* temp = secondary_;
  secondary_ = NULL;
  return temp;
}
inline ::navigator::DirectionsBannerSection* DirectionsBannerInstruction::mutable_secondary() {
  set_has_secondary();
  if (secondary_ == NULL) {
    secondary_ = new ::navigator::DirectionsBannerSection;
  }
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsBannerInstruction.secondary)
  return secondary_;
}
inline void DirectionsBannerInstruction::set_allocated_secondary(::navigator::DirectionsBannerSection* secondary) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete secondary_;
  }
  if (secondary) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      secondary = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, secondary, submessage_arena);
    }
    set_has_secondary();
  } else {
    clear_has_secondary();
  }
  secondary_ = secondary;
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsBannerInstruction.secondary)
}

// optional .navigator.DirectionsBannerSection sub = 4;
inline bool DirectionsBannerInstruction::has_sub() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectionsBannerInstruction::set_has_sub() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectionsBannerInstruction::clear_has_sub() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectionsBannerInstruction::clear_sub() {
  if (sub_ != NULL) sub_->Clear();
  clear_has_sub();
}
inline const ::navigator::DirectionsBannerSection& DirectionsBannerInstruction::sub() const {
  const ::navigator::DirectionsBannerSection* p = sub_;
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerInstruction.sub)
  return p != NULL ? *p : *reinterpret_cast<const ::navigator::DirectionsBannerSection*>(
      &::navigator::_DirectionsBannerSection_default_instance_);
}
inline ::navigator::DirectionsBannerSection* DirectionsBannerInstruction::release_sub() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsBannerInstruction.sub)
  clear_has_sub();
  ::navigator::DirectionsBannerSection* temp = sub_;
  sub_ = NULL;
  return temp;
}
inline ::navigator::DirectionsBannerSection* DirectionsBannerInstruction::mutable_sub() {
  set_has_sub();
  if (sub_ == NULL) {
    sub_ = new ::navigator::DirectionsBannerSection;
  }
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsBannerInstruction.sub)
  return sub_;
}
inline void DirectionsBannerInstruction::set_allocated_sub(::navigator::DirectionsBannerSection* sub) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sub_;
  }
  if (sub) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sub = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sub, submessage_arena);
    }
    set_has_sub();
  } else {
    clear_has_sub();
  }
  sub_ = sub;
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsBannerInstruction.sub)
}

// optional bool used = 5;
inline bool DirectionsBannerInstruction::has_used() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DirectionsBannerInstruction::set_has_used() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DirectionsBannerInstruction::clear_has_used() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DirectionsBannerInstruction::clear_used() {
  used_ = false;
  clear_has_used();
}
inline bool DirectionsBannerInstruction::used() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsBannerInstruction.used)
  return used_;
}
inline void DirectionsBannerInstruction::set_used(bool value) {
  set_has_used();
  used_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsBannerInstruction.used)
}

// -------------------------------------------------------------------

// DirectionsVoiceInstruction

// optional float remaining_step_distance = 1;
inline bool DirectionsVoiceInstruction::has_remaining_step_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectionsVoiceInstruction::set_has_remaining_step_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectionsVoiceInstruction::clear_has_remaining_step_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectionsVoiceInstruction::clear_remaining_step_distance() {
  remaining_step_distance_ = 0;
  clear_has_remaining_step_distance();
}
inline float DirectionsVoiceInstruction::remaining_step_distance() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsVoiceInstruction.remaining_step_distance)
  return remaining_step_distance_;
}
inline void DirectionsVoiceInstruction::set_remaining_step_distance(float value) {
  set_has_remaining_step_distance();
  remaining_step_distance_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsVoiceInstruction.remaining_step_distance)
}

// optional string announcement = 2;
inline bool DirectionsVoiceInstruction::has_announcement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsVoiceInstruction::set_has_announcement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsVoiceInstruction::clear_has_announcement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsVoiceInstruction::clear_announcement() {
  announcement_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_announcement();
}
inline const ::std::string& DirectionsVoiceInstruction::announcement() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsVoiceInstruction.announcement)
  return announcement_.GetNoArena();
}
inline void DirectionsVoiceInstruction::set_announcement(const ::std::string& value) {
  set_has_announcement();
  announcement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsVoiceInstruction.announcement)
}
#if LANG_CXX11
inline void DirectionsVoiceInstruction::set_announcement(::std::string&& value) {
  set_has_announcement();
  announcement_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsVoiceInstruction.announcement)
}
#endif
inline void DirectionsVoiceInstruction::set_announcement(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_announcement();
  announcement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsVoiceInstruction.announcement)
}
inline void DirectionsVoiceInstruction::set_announcement(const char* value, size_t size) {
  set_has_announcement();
  announcement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsVoiceInstruction.announcement)
}
inline ::std::string* DirectionsVoiceInstruction::mutable_announcement() {
  set_has_announcement();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsVoiceInstruction.announcement)
  return announcement_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsVoiceInstruction::release_announcement() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsVoiceInstruction.announcement)
  clear_has_announcement();
  return announcement_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsVoiceInstruction::set_allocated_announcement(::std::string* announcement) {
  if (announcement != NULL) {
    set_has_announcement();
  } else {
    clear_has_announcement();
  }
  announcement_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), announcement);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsVoiceInstruction.announcement)
}

// optional string ssml_announcement = 3;
inline bool DirectionsVoiceInstruction::has_ssml_announcement() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsVoiceInstruction::set_has_ssml_announcement() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsVoiceInstruction::clear_has_ssml_announcement() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsVoiceInstruction::clear_ssml_announcement() {
  ssml_announcement_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ssml_announcement();
}
inline const ::std::string& DirectionsVoiceInstruction::ssml_announcement() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsVoiceInstruction.ssml_announcement)
  return ssml_announcement_.GetNoArena();
}
inline void DirectionsVoiceInstruction::set_ssml_announcement(const ::std::string& value) {
  set_has_ssml_announcement();
  ssml_announcement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsVoiceInstruction.ssml_announcement)
}
#if LANG_CXX11
inline void DirectionsVoiceInstruction::set_ssml_announcement(::std::string&& value) {
  set_has_ssml_announcement();
  ssml_announcement_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsVoiceInstruction.ssml_announcement)
}
#endif
inline void DirectionsVoiceInstruction::set_ssml_announcement(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ssml_announcement();
  ssml_announcement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsVoiceInstruction.ssml_announcement)
}
inline void DirectionsVoiceInstruction::set_ssml_announcement(const char* value, size_t size) {
  set_has_ssml_announcement();
  ssml_announcement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsVoiceInstruction.ssml_announcement)
}
inline ::std::string* DirectionsVoiceInstruction::mutable_ssml_announcement() {
  set_has_ssml_announcement();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsVoiceInstruction.ssml_announcement)
  return ssml_announcement_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsVoiceInstruction::release_ssml_announcement() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsVoiceInstruction.ssml_announcement)
  clear_has_ssml_announcement();
  return ssml_announcement_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsVoiceInstruction::set_allocated_ssml_announcement(::std::string* ssml_announcement) {
  if (ssml_announcement != NULL) {
    set_has_ssml_announcement();
  } else {
    clear_has_ssml_announcement();
  }
  ssml_announcement_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssml_announcement);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsVoiceInstruction.ssml_announcement)
}

// optional bool used = 4;
inline bool DirectionsVoiceInstruction::has_used() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectionsVoiceInstruction::set_has_used() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectionsVoiceInstruction::clear_has_used() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectionsVoiceInstruction::clear_used() {
  used_ = false;
  clear_has_used();
}
inline bool DirectionsVoiceInstruction::used() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsVoiceInstruction.used)
  return used_;
}
inline void DirectionsVoiceInstruction::set_used(bool value) {
  set_has_used();
  used_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsVoiceInstruction.used)
}

// -------------------------------------------------------------------

// DirectionsLane

// optional bool valid = 1;
inline bool DirectionsLane::has_valid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsLane::set_has_valid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsLane::clear_has_valid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsLane::clear_valid() {
  valid_ = false;
  clear_has_valid();
}
inline bool DirectionsLane::valid() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLane.valid)
  return valid_;
}
inline void DirectionsLane::set_valid(bool value) {
  set_has_valid();
  valid_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsLane.valid)
}

// repeated string indications = 2;
inline int DirectionsLane::indications_size() const {
  return indications_.size();
}
inline void DirectionsLane::clear_indications() {
  indications_.Clear();
}
inline const ::std::string& DirectionsLane::indications(int index) const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLane.indications)
  return indications_.Get(index);
}
inline ::std::string* DirectionsLane::mutable_indications(int index) {
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsLane.indications)
  return indications_.Mutable(index);
}
inline void DirectionsLane::set_indications(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:navigator.DirectionsLane.indications)
  indications_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DirectionsLane::set_indications(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:navigator.DirectionsLane.indications)
  indications_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DirectionsLane::set_indications(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  indications_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsLane.indications)
}
inline void DirectionsLane::set_indications(int index, const char* value, size_t size) {
  indications_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsLane.indications)
}
inline ::std::string* DirectionsLane::add_indications() {
  // @@protoc_insertion_point(field_add_mutable:navigator.DirectionsLane.indications)
  return indications_.Add();
}
inline void DirectionsLane::add_indications(const ::std::string& value) {
  indications_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:navigator.DirectionsLane.indications)
}
#if LANG_CXX11
inline void DirectionsLane::add_indications(::std::string&& value) {
  indications_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:navigator.DirectionsLane.indications)
}
#endif
inline void DirectionsLane::add_indications(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  indications_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:navigator.DirectionsLane.indications)
}
inline void DirectionsLane::add_indications(const char* value, size_t size) {
  indications_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:navigator.DirectionsLane.indications)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DirectionsLane::indications() const {
  // @@protoc_insertion_point(field_list:navigator.DirectionsLane.indications)
  return indications_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DirectionsLane::mutable_indications() {
  // @@protoc_insertion_point(field_mutable_list:navigator.DirectionsLane.indications)
  return &indications_;
}

// -------------------------------------------------------------------

// DirectionsIntersection

// optional uint32 shape_index = 1;
inline bool DirectionsIntersection::has_shape_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsIntersection::set_has_shape_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsIntersection::clear_has_shape_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsIntersection::clear_shape_index() {
  shape_index_ = 0u;
  clear_has_shape_index();
}
inline ::google::protobuf::uint32 DirectionsIntersection::shape_index() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsIntersection.shape_index)
  return shape_index_;
}
inline void DirectionsIntersection::set_shape_index(::google::protobuf::uint32 value) {
  set_has_shape_index();
  shape_index_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsIntersection.shape_index)
}

// repeated double bearings = 2;
inline int DirectionsIntersection::bearings_size() const {
  return bearings_.size();
}
inline void DirectionsIntersection::clear_bearings() {
  bearings_.Clear();
}
inline double DirectionsIntersection::bearings(int index) const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsIntersection.bearings)
  return bearings_.Get(index);
}
inline void DirectionsIntersection::set_bearings(int index, double value) {
  bearings_.Set(index, value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsIntersection.bearings)
}
inline void DirectionsIntersection::add_bearings(double value) {
  bearings_.Add(value);
  // @@protoc_insertion_point(field_add:navigator.DirectionsIntersection.bearings)
}
inline const ::google::protobuf::RepeatedField< double >&
DirectionsIntersection::bearings() const {
  // @@protoc_insertion_point(field_list:navigator.DirectionsIntersection.bearings)
  return bearings_;
}
inline ::google::protobuf::RepeatedField< double >*
DirectionsIntersection::mutable_bearings() {
  // @@protoc_insertion_point(field_mutable_list:navigator.DirectionsIntersection.bearings)
  return &bearings_;
}

// repeated .navigator.DirectionsIntersection.Class classes = 3;
inline int DirectionsIntersection::classes_size() const {
  return classes_.size();
}
inline void DirectionsIntersection::clear_classes() {
  classes_.Clear();
}
inline ::navigator::DirectionsIntersection_Class DirectionsIntersection::classes(int index) const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsIntersection.classes)
  return static_cast< ::navigator::DirectionsIntersection_Class >(classes_.Get(index));
}
inline void DirectionsIntersection::set_classes(int index, ::navigator::DirectionsIntersection_Class value) {
  assert(::navigator::DirectionsIntersection_Class_IsValid(value));
  classes_.Set(index, value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsIntersection.classes)
}
inline void DirectionsIntersection::add_classes(::navigator::DirectionsIntersection_Class value) {
  assert(::navigator::DirectionsIntersection_Class_IsValid(value));
  classes_.Add(value);
  // @@protoc_insertion_point(field_add:navigator.DirectionsIntersection.classes)
}
inline const ::google::protobuf::RepeatedField<int>&
DirectionsIntersection::classes() const {
  // @@protoc_insertion_point(field_list:navigator.DirectionsIntersection.classes)
  return classes_;
}
inline ::google::protobuf::RepeatedField<int>*
DirectionsIntersection::mutable_classes() {
  // @@protoc_insertion_point(field_mutable_list:navigator.DirectionsIntersection.classes)
  return &classes_;
}

// repeated bool entries = 4;
inline int DirectionsIntersection::entries_size() const {
  return entries_.size();
}
inline void DirectionsIntersection::clear_entries() {
  entries_.Clear();
}
inline bool DirectionsIntersection::entries(int index) const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsIntersection.entries)
  return entries_.Get(index);
}
inline void DirectionsIntersection::set_entries(int index, bool value) {
  entries_.Set(index, value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsIntersection.entries)
}
inline void DirectionsIntersection::add_entries(bool value) {
  entries_.Add(value);
  // @@protoc_insertion_point(field_add:navigator.DirectionsIntersection.entries)
}
inline const ::google::protobuf::RepeatedField< bool >&
DirectionsIntersection::entries() const {
  // @@protoc_insertion_point(field_list:navigator.DirectionsIntersection.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedField< bool >*
DirectionsIntersection::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:navigator.DirectionsIntersection.entries)
  return &entries_;
}

// optional uint32 in = 5;
inline bool DirectionsIntersection::has_in() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsIntersection::set_has_in() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsIntersection::clear_has_in() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsIntersection::clear_in() {
  in_ = 0u;
  clear_has_in();
}
inline ::google::protobuf::uint32 DirectionsIntersection::in() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsIntersection.in)
  return in_;
}
inline void DirectionsIntersection::set_in(::google::protobuf::uint32 value) {
  set_has_in();
  in_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsIntersection.in)
}

// optional uint32 out = 6;
inline bool DirectionsIntersection::has_out() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectionsIntersection::set_has_out() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectionsIntersection::clear_has_out() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectionsIntersection::clear_out() {
  out_ = 0u;
  clear_has_out();
}
inline ::google::protobuf::uint32 DirectionsIntersection::out() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsIntersection.out)
  return out_;
}
inline void DirectionsIntersection::set_out(::google::protobuf::uint32 value) {
  set_has_out();
  out_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsIntersection.out)
}

// repeated .navigator.DirectionsLane lanes = 7;
inline int DirectionsIntersection::lanes_size() const {
  return lanes_.size();
}
inline void DirectionsIntersection::clear_lanes() {
  lanes_.Clear();
}
inline const ::navigator::DirectionsLane& DirectionsIntersection::lanes(int index) const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsIntersection.lanes)
  return lanes_.Get(index);
}
inline ::navigator::DirectionsLane* DirectionsIntersection::mutable_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsIntersection.lanes)
  return lanes_.Mutable(index);
}
inline ::navigator::DirectionsLane* DirectionsIntersection::add_lanes() {
  // @@protoc_insertion_point(field_add:navigator.DirectionsIntersection.lanes)
  return lanes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLane >*
DirectionsIntersection::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:navigator.DirectionsIntersection.lanes)
  return &lanes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLane >&
DirectionsIntersection::lanes() const {
  // @@protoc_insertion_point(field_list:navigator.DirectionsIntersection.lanes)
  return lanes_;
}

// -------------------------------------------------------------------

// DirectionsStreetName

// optional string text = 1;
inline bool DirectionsStreetName::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsStreetName::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsStreetName::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsStreetName::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& DirectionsStreetName::text() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsStreetName.text)
  return text_.GetNoArena();
}
inline void DirectionsStreetName::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsStreetName.text)
}
#if LANG_CXX11
inline void DirectionsStreetName::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsStreetName.text)
}
#endif
inline void DirectionsStreetName::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsStreetName.text)
}
inline void DirectionsStreetName::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsStreetName.text)
}
inline ::std::string* DirectionsStreetName::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsStreetName.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsStreetName::release_text() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsStreetName.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsStreetName::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsStreetName.text)
}

// -------------------------------------------------------------------

// DirectionsManeuver

// optional string type = 1;
inline bool DirectionsManeuver::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsManeuver::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsManeuver::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsManeuver::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& DirectionsManeuver::type() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsManeuver.type)
  return type_.GetNoArena();
}
inline void DirectionsManeuver::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsManeuver.type)
}
#if LANG_CXX11
inline void DirectionsManeuver::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsManeuver.type)
}
#endif
inline void DirectionsManeuver::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsManeuver.type)
}
inline void DirectionsManeuver::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsManeuver.type)
}
inline ::std::string* DirectionsManeuver::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsManeuver.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsManeuver::release_type() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsManeuver.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsManeuver::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsManeuver.type)
}

// optional string modifier = 2;
inline bool DirectionsManeuver::has_modifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsManeuver::set_has_modifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsManeuver::clear_has_modifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsManeuver::clear_modifier() {
  modifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_modifier();
}
inline const ::std::string& DirectionsManeuver::modifier() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsManeuver.modifier)
  return modifier_.GetNoArena();
}
inline void DirectionsManeuver::set_modifier(const ::std::string& value) {
  set_has_modifier();
  modifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsManeuver.modifier)
}
#if LANG_CXX11
inline void DirectionsManeuver::set_modifier(::std::string&& value) {
  set_has_modifier();
  modifier_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsManeuver.modifier)
}
#endif
inline void DirectionsManeuver::set_modifier(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_modifier();
  modifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsManeuver.modifier)
}
inline void DirectionsManeuver::set_modifier(const char* value, size_t size) {
  set_has_modifier();
  modifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsManeuver.modifier)
}
inline ::std::string* DirectionsManeuver::mutable_modifier() {
  set_has_modifier();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsManeuver.modifier)
  return modifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsManeuver::release_modifier() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsManeuver.modifier)
  clear_has_modifier();
  return modifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsManeuver::set_allocated_modifier(::std::string* modifier) {
  if (modifier != NULL) {
    set_has_modifier();
  } else {
    clear_has_modifier();
  }
  modifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modifier);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsManeuver.modifier)
}

// optional string instruction = 3;
inline bool DirectionsManeuver::has_instruction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectionsManeuver::set_has_instruction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectionsManeuver::clear_has_instruction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectionsManeuver::clear_instruction() {
  instruction_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_instruction();
}
inline const ::std::string& DirectionsManeuver::instruction() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsManeuver.instruction)
  return instruction_.GetNoArena();
}
inline void DirectionsManeuver::set_instruction(const ::std::string& value) {
  set_has_instruction();
  instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsManeuver.instruction)
}
#if LANG_CXX11
inline void DirectionsManeuver::set_instruction(::std::string&& value) {
  set_has_instruction();
  instruction_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsManeuver.instruction)
}
#endif
inline void DirectionsManeuver::set_instruction(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_instruction();
  instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsManeuver.instruction)
}
inline void DirectionsManeuver::set_instruction(const char* value, size_t size) {
  set_has_instruction();
  instruction_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsManeuver.instruction)
}
inline ::std::string* DirectionsManeuver::mutable_instruction() {
  set_has_instruction();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsManeuver.instruction)
  return instruction_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsManeuver::release_instruction() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsManeuver.instruction)
  clear_has_instruction();
  return instruction_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsManeuver::set_allocated_instruction(::std::string* instruction) {
  if (instruction != NULL) {
    set_has_instruction();
  } else {
    clear_has_instruction();
  }
  instruction_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instruction);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsManeuver.instruction)
}

// optional uint32 bearing_before = 4;
inline bool DirectionsManeuver::has_bearing_before() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectionsManeuver::set_has_bearing_before() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectionsManeuver::clear_has_bearing_before() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectionsManeuver::clear_bearing_before() {
  bearing_before_ = 0u;
  clear_has_bearing_before();
}
inline ::google::protobuf::uint32 DirectionsManeuver::bearing_before() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsManeuver.bearing_before)
  return bearing_before_;
}
inline void DirectionsManeuver::set_bearing_before(::google::protobuf::uint32 value) {
  set_has_bearing_before();
  bearing_before_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsManeuver.bearing_before)
}

// optional uint32 bearing_after = 5;
inline bool DirectionsManeuver::has_bearing_after() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DirectionsManeuver::set_has_bearing_after() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DirectionsManeuver::clear_has_bearing_after() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DirectionsManeuver::clear_bearing_after() {
  bearing_after_ = 0u;
  clear_has_bearing_after();
}
inline ::google::protobuf::uint32 DirectionsManeuver::bearing_after() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsManeuver.bearing_after)
  return bearing_after_;
}
inline void DirectionsManeuver::set_bearing_after(::google::protobuf::uint32 value) {
  set_has_bearing_after();
  bearing_after_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsManeuver.bearing_after)
}

// repeated .navigator.DirectionsStreetName street_names = 7;
inline int DirectionsManeuver::street_names_size() const {
  return street_names_.size();
}
inline void DirectionsManeuver::clear_street_names() {
  street_names_.Clear();
}
inline const ::navigator::DirectionsStreetName& DirectionsManeuver::street_names(int index) const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsManeuver.street_names)
  return street_names_.Get(index);
}
inline ::navigator::DirectionsStreetName* DirectionsManeuver::mutable_street_names(int index) {
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsManeuver.street_names)
  return street_names_.Mutable(index);
}
inline ::navigator::DirectionsStreetName* DirectionsManeuver::add_street_names() {
  // @@protoc_insertion_point(field_add:navigator.DirectionsManeuver.street_names)
  return street_names_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStreetName >*
DirectionsManeuver::mutable_street_names() {
  // @@protoc_insertion_point(field_mutable_list:navigator.DirectionsManeuver.street_names)
  return &street_names_;
}
inline const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStreetName >&
DirectionsManeuver::street_names() const {
  // @@protoc_insertion_point(field_list:navigator.DirectionsManeuver.street_names)
  return street_names_;
}

// -------------------------------------------------------------------

// DirectionsStep

// optional .navigator.DirectionsManeuver maneuver = 1;
inline bool DirectionsStep::has_maneuver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectionsStep::set_has_maneuver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectionsStep::clear_has_maneuver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectionsStep::clear_maneuver() {
  if (maneuver_ != NULL) maneuver_->Clear();
  clear_has_maneuver();
}
inline const ::navigator::DirectionsManeuver& DirectionsStep::maneuver() const {
  const ::navigator::DirectionsManeuver* p = maneuver_;
  // @@protoc_insertion_point(field_get:navigator.DirectionsStep.maneuver)
  return p != NULL ? *p : *reinterpret_cast<const ::navigator::DirectionsManeuver*>(
      &::navigator::_DirectionsManeuver_default_instance_);
}
inline ::navigator::DirectionsManeuver* DirectionsStep::release_maneuver() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsStep.maneuver)
  clear_has_maneuver();
  ::navigator::DirectionsManeuver* temp = maneuver_;
  maneuver_ = NULL;
  return temp;
}
inline ::navigator::DirectionsManeuver* DirectionsStep::mutable_maneuver() {
  set_has_maneuver();
  if (maneuver_ == NULL) {
    maneuver_ = new ::navigator::DirectionsManeuver;
  }
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsStep.maneuver)
  return maneuver_;
}
inline void DirectionsStep::set_allocated_maneuver(::navigator::DirectionsManeuver* maneuver) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete maneuver_;
  }
  if (maneuver) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      maneuver = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, maneuver, submessage_arena);
    }
    set_has_maneuver();
  } else {
    clear_has_maneuver();
  }
  maneuver_ = maneuver;
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsStep.maneuver)
}

// optional float distance = 2;
inline bool DirectionsStep::has_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DirectionsStep::set_has_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DirectionsStep::clear_has_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DirectionsStep::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float DirectionsStep::distance() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsStep.distance)
  return distance_;
}
inline void DirectionsStep::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsStep.distance)
}

// optional uint32 duration = 3;
inline bool DirectionsStep::has_duration() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DirectionsStep::set_has_duration() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DirectionsStep::clear_has_duration() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DirectionsStep::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 DirectionsStep::duration() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsStep.duration)
  return duration_;
}
inline void DirectionsStep::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsStep.duration)
}

// repeated .navigator.DirectionsVoiceInstruction voice_instructions = 4;
inline int DirectionsStep::voice_instructions_size() const {
  return voice_instructions_.size();
}
inline void DirectionsStep::clear_voice_instructions() {
  voice_instructions_.Clear();
}
inline const ::navigator::DirectionsVoiceInstruction& DirectionsStep::voice_instructions(int index) const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsStep.voice_instructions)
  return voice_instructions_.Get(index);
}
inline ::navigator::DirectionsVoiceInstruction* DirectionsStep::mutable_voice_instructions(int index) {
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsStep.voice_instructions)
  return voice_instructions_.Mutable(index);
}
inline ::navigator::DirectionsVoiceInstruction* DirectionsStep::add_voice_instructions() {
  // @@protoc_insertion_point(field_add:navigator.DirectionsStep.voice_instructions)
  return voice_instructions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsVoiceInstruction >*
DirectionsStep::mutable_voice_instructions() {
  // @@protoc_insertion_point(field_mutable_list:navigator.DirectionsStep.voice_instructions)
  return &voice_instructions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsVoiceInstruction >&
DirectionsStep::voice_instructions() const {
  // @@protoc_insertion_point(field_list:navigator.DirectionsStep.voice_instructions)
  return voice_instructions_;
}

// repeated .navigator.DirectionsBannerInstruction banner_instructions = 5;
inline int DirectionsStep::banner_instructions_size() const {
  return banner_instructions_.size();
}
inline void DirectionsStep::clear_banner_instructions() {
  banner_instructions_.Clear();
}
inline const ::navigator::DirectionsBannerInstruction& DirectionsStep::banner_instructions(int index) const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsStep.banner_instructions)
  return banner_instructions_.Get(index);
}
inline ::navigator::DirectionsBannerInstruction* DirectionsStep::mutable_banner_instructions(int index) {
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsStep.banner_instructions)
  return banner_instructions_.Mutable(index);
}
inline ::navigator::DirectionsBannerInstruction* DirectionsStep::add_banner_instructions() {
  // @@protoc_insertion_point(field_add:navigator.DirectionsStep.banner_instructions)
  return banner_instructions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsBannerInstruction >*
DirectionsStep::mutable_banner_instructions() {
  // @@protoc_insertion_point(field_mutable_list:navigator.DirectionsStep.banner_instructions)
  return &banner_instructions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsBannerInstruction >&
DirectionsStep::banner_instructions() const {
  // @@protoc_insertion_point(field_list:navigator.DirectionsStep.banner_instructions)
  return banner_instructions_;
}

// repeated .navigator.DirectionsStreetName street_names = 6;
inline int DirectionsStep::street_names_size() const {
  return street_names_.size();
}
inline void DirectionsStep::clear_street_names() {
  street_names_.Clear();
}
inline const ::navigator::DirectionsStreetName& DirectionsStep::street_names(int index) const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsStep.street_names)
  return street_names_.Get(index);
}
inline ::navigator::DirectionsStreetName* DirectionsStep::mutable_street_names(int index) {
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsStep.street_names)
  return street_names_.Mutable(index);
}
inline ::navigator::DirectionsStreetName* DirectionsStep::add_street_names() {
  // @@protoc_insertion_point(field_add:navigator.DirectionsStep.street_names)
  return street_names_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStreetName >*
DirectionsStep::mutable_street_names() {
  // @@protoc_insertion_point(field_mutable_list:navigator.DirectionsStep.street_names)
  return &street_names_;
}
inline const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStreetName >&
DirectionsStep::street_names() const {
  // @@protoc_insertion_point(field_list:navigator.DirectionsStep.street_names)
  return street_names_;
}

// optional uint32 begin_shape_index = 7;
inline bool DirectionsStep::has_begin_shape_index() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DirectionsStep::set_has_begin_shape_index() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DirectionsStep::clear_has_begin_shape_index() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DirectionsStep::clear_begin_shape_index() {
  begin_shape_index_ = 0u;
  clear_has_begin_shape_index();
}
inline ::google::protobuf::uint32 DirectionsStep::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsStep.begin_shape_index)
  return begin_shape_index_;
}
inline void DirectionsStep::set_begin_shape_index(::google::protobuf::uint32 value) {
  set_has_begin_shape_index();
  begin_shape_index_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsStep.begin_shape_index)
}

// optional uint32 end_shape_index = 8;
inline bool DirectionsStep::has_end_shape_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DirectionsStep::set_has_end_shape_index() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DirectionsStep::clear_has_end_shape_index() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DirectionsStep::clear_end_shape_index() {
  end_shape_index_ = 0u;
  clear_has_end_shape_index();
}
inline ::google::protobuf::uint32 DirectionsStep::end_shape_index() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsStep.end_shape_index)
  return end_shape_index_;
}
inline void DirectionsStep::set_end_shape_index(::google::protobuf::uint32 value) {
  set_has_end_shape_index();
  end_shape_index_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsStep.end_shape_index)
}

// optional string travel_mode = 9;
inline bool DirectionsStep::has_travel_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsStep::set_has_travel_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsStep::clear_has_travel_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsStep::clear_travel_mode() {
  travel_mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_travel_mode();
}
inline const ::std::string& DirectionsStep::travel_mode() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsStep.travel_mode)
  return travel_mode_.GetNoArena();
}
inline void DirectionsStep::set_travel_mode(const ::std::string& value) {
  set_has_travel_mode();
  travel_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsStep.travel_mode)
}
#if LANG_CXX11
inline void DirectionsStep::set_travel_mode(::std::string&& value) {
  set_has_travel_mode();
  travel_mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsStep.travel_mode)
}
#endif
inline void DirectionsStep::set_travel_mode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_travel_mode();
  travel_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsStep.travel_mode)
}
inline void DirectionsStep::set_travel_mode(const char* value, size_t size) {
  set_has_travel_mode();
  travel_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsStep.travel_mode)
}
inline ::std::string* DirectionsStep::mutable_travel_mode() {
  set_has_travel_mode();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsStep.travel_mode)
  return travel_mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsStep::release_travel_mode() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsStep.travel_mode)
  clear_has_travel_mode();
  return travel_mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsStep::set_allocated_travel_mode(::std::string* travel_mode) {
  if (travel_mode != NULL) {
    set_has_travel_mode();
  } else {
    clear_has_travel_mode();
  }
  travel_mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), travel_mode);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsStep.travel_mode)
}

// optional string travel_type = 10;
inline bool DirectionsStep::has_travel_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsStep::set_has_travel_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsStep::clear_has_travel_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsStep::clear_travel_type() {
  travel_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_travel_type();
}
inline const ::std::string& DirectionsStep::travel_type() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsStep.travel_type)
  return travel_type_.GetNoArena();
}
inline void DirectionsStep::set_travel_type(const ::std::string& value) {
  set_has_travel_type();
  travel_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsStep.travel_type)
}
#if LANG_CXX11
inline void DirectionsStep::set_travel_type(::std::string&& value) {
  set_has_travel_type();
  travel_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsStep.travel_type)
}
#endif
inline void DirectionsStep::set_travel_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_travel_type();
  travel_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsStep.travel_type)
}
inline void DirectionsStep::set_travel_type(const char* value, size_t size) {
  set_has_travel_type();
  travel_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsStep.travel_type)
}
inline ::std::string* DirectionsStep::mutable_travel_type() {
  set_has_travel_type();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsStep.travel_type)
  return travel_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsStep::release_travel_type() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsStep.travel_type)
  clear_has_travel_type();
  return travel_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsStep::set_allocated_travel_type(::std::string* travel_type) {
  if (travel_type != NULL) {
    set_has_travel_type();
  } else {
    clear_has_travel_type();
  }
  travel_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), travel_type);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsStep.travel_type)
}

// repeated .navigator.DirectionsIntersection intersections = 11;
inline int DirectionsStep::intersections_size() const {
  return intersections_.size();
}
inline void DirectionsStep::clear_intersections() {
  intersections_.Clear();
}
inline const ::navigator::DirectionsIntersection& DirectionsStep::intersections(int index) const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsStep.intersections)
  return intersections_.Get(index);
}
inline ::navigator::DirectionsIntersection* DirectionsStep::mutable_intersections(int index) {
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsStep.intersections)
  return intersections_.Mutable(index);
}
inline ::navigator::DirectionsIntersection* DirectionsStep::add_intersections() {
  // @@protoc_insertion_point(field_add:navigator.DirectionsStep.intersections)
  return intersections_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsIntersection >*
DirectionsStep::mutable_intersections() {
  // @@protoc_insertion_point(field_mutable_list:navigator.DirectionsStep.intersections)
  return &intersections_;
}
inline const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsIntersection >&
DirectionsStep::intersections() const {
  // @@protoc_insertion_point(field_list:navigator.DirectionsStep.intersections)
  return intersections_;
}

// optional string driving_side = 12;
inline bool DirectionsStep::has_driving_side() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectionsStep::set_has_driving_side() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectionsStep::clear_has_driving_side() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectionsStep::clear_driving_side() {
  driving_side_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_driving_side();
}
inline const ::std::string& DirectionsStep::driving_side() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsStep.driving_side)
  return driving_side_.GetNoArena();
}
inline void DirectionsStep::set_driving_side(const ::std::string& value) {
  set_has_driving_side();
  driving_side_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsStep.driving_side)
}
#if LANG_CXX11
inline void DirectionsStep::set_driving_side(::std::string&& value) {
  set_has_driving_side();
  driving_side_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsStep.driving_side)
}
#endif
inline void DirectionsStep::set_driving_side(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_driving_side();
  driving_side_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsStep.driving_side)
}
inline void DirectionsStep::set_driving_side(const char* value, size_t size) {
  set_has_driving_side();
  driving_side_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsStep.driving_side)
}
inline ::std::string* DirectionsStep::mutable_driving_side() {
  set_has_driving_side();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsStep.driving_side)
  return driving_side_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsStep::release_driving_side() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsStep.driving_side)
  clear_has_driving_side();
  return driving_side_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsStep::set_allocated_driving_side(::std::string* driving_side) {
  if (driving_side != NULL) {
    set_has_driving_side();
  } else {
    clear_has_driving_side();
  }
  driving_side_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driving_side);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsStep.driving_side)
}

// optional bool toll = 13;
inline bool DirectionsStep::has_toll() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DirectionsStep::set_has_toll() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DirectionsStep::clear_has_toll() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DirectionsStep::clear_toll() {
  toll_ = false;
  clear_has_toll();
}
inline bool DirectionsStep::toll() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsStep.toll)
  return toll_;
}
inline void DirectionsStep::set_toll(bool value) {
  set_has_toll();
  toll_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsStep.toll)
}

// optional bool rough = 14;
inline bool DirectionsStep::has_rough() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DirectionsStep::set_has_rough() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DirectionsStep::clear_has_rough() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DirectionsStep::clear_rough() {
  rough_ = false;
  clear_has_rough();
}
inline bool DirectionsStep::rough() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsStep.rough)
  return rough_;
}
inline void DirectionsStep::set_rough(bool value) {
  set_has_rough();
  rough_ = value;
  // @@protoc_insertion_point(field_set:navigator.DirectionsStep.rough)
}

// -------------------------------------------------------------------

// DirectionsLeg

// optional .navigator.DirectionsSummary summary = 1;
inline bool DirectionsLeg::has_summary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsLeg::set_has_summary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsLeg::clear_has_summary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsLeg::clear_summary() {
  if (summary_ != NULL) summary_->Clear();
  clear_has_summary();
}
inline const ::navigator::DirectionsSummary& DirectionsLeg::summary() const {
  const ::navigator::DirectionsSummary* p = summary_;
  // @@protoc_insertion_point(field_get:navigator.DirectionsLeg.summary)
  return p != NULL ? *p : *reinterpret_cast<const ::navigator::DirectionsSummary*>(
      &::navigator::_DirectionsSummary_default_instance_);
}
inline ::navigator::DirectionsSummary* DirectionsLeg::release_summary() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsLeg.summary)
  clear_has_summary();
  ::navigator::DirectionsSummary* temp = summary_;
  summary_ = NULL;
  return temp;
}
inline ::navigator::DirectionsSummary* DirectionsLeg::mutable_summary() {
  set_has_summary();
  if (summary_ == NULL) {
    summary_ = new ::navigator::DirectionsSummary;
  }
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsLeg.summary)
  return summary_;
}
inline void DirectionsLeg::set_allocated_summary(::navigator::DirectionsSummary* summary) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete summary_;
  }
  if (summary) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      summary = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, summary, submessage_arena);
    }
    set_has_summary();
  } else {
    clear_has_summary();
  }
  summary_ = summary;
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsLeg.summary)
}

// repeated .navigator.DirectionsStep steps = 2;
inline int DirectionsLeg::steps_size() const {
  return steps_.size();
}
inline void DirectionsLeg::clear_steps() {
  steps_.Clear();
}
inline const ::navigator::DirectionsStep& DirectionsLeg::steps(int index) const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLeg.steps)
  return steps_.Get(index);
}
inline ::navigator::DirectionsStep* DirectionsLeg::mutable_steps(int index) {
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsLeg.steps)
  return steps_.Mutable(index);
}
inline ::navigator::DirectionsStep* DirectionsLeg::add_steps() {
  // @@protoc_insertion_point(field_add:navigator.DirectionsLeg.steps)
  return steps_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStep >*
DirectionsLeg::mutable_steps() {
  // @@protoc_insertion_point(field_mutable_list:navigator.DirectionsLeg.steps)
  return &steps_;
}
inline const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsStep >&
DirectionsLeg::steps() const {
  // @@protoc_insertion_point(field_list:navigator.DirectionsLeg.steps)
  return steps_;
}

// optional string shape = 3;
inline bool DirectionsLeg::has_shape() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsLeg::set_has_shape() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsLeg::clear_has_shape() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsLeg::clear_shape() {
  shape_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_shape();
}
inline const ::std::string& DirectionsLeg::shape() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsLeg.shape)
  return shape_.GetNoArena();
}
inline void DirectionsLeg::set_shape(const ::std::string& value) {
  set_has_shape();
  shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsLeg.shape)
}
#if LANG_CXX11
inline void DirectionsLeg::set_shape(::std::string&& value) {
  set_has_shape();
  shape_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsLeg.shape)
}
#endif
inline void DirectionsLeg::set_shape(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_shape();
  shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsLeg.shape)
}
inline void DirectionsLeg::set_shape(const char* value, size_t size) {
  set_has_shape();
  shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsLeg.shape)
}
inline ::std::string* DirectionsLeg::mutable_shape() {
  set_has_shape();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsLeg.shape)
  return shape_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsLeg::release_shape() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsLeg.shape)
  clear_has_shape();
  return shape_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsLeg::set_allocated_shape(::std::string* shape) {
  if (shape != NULL) {
    set_has_shape();
  } else {
    clear_has_shape();
  }
  shape_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shape);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsLeg.shape)
}

// -------------------------------------------------------------------

// DirectionsRoute

// optional .navigator.DirectionsSummary summary = 1;
inline bool DirectionsRoute::has_summary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsRoute::set_has_summary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsRoute::clear_has_summary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsRoute::clear_summary() {
  if (summary_ != NULL) summary_->Clear();
  clear_has_summary();
}
inline const ::navigator::DirectionsSummary& DirectionsRoute::summary() const {
  const ::navigator::DirectionsSummary* p = summary_;
  // @@protoc_insertion_point(field_get:navigator.DirectionsRoute.summary)
  return p != NULL ? *p : *reinterpret_cast<const ::navigator::DirectionsSummary*>(
      &::navigator::_DirectionsSummary_default_instance_);
}
inline ::navigator::DirectionsSummary* DirectionsRoute::release_summary() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsRoute.summary)
  clear_has_summary();
  ::navigator::DirectionsSummary* temp = summary_;
  summary_ = NULL;
  return temp;
}
inline ::navigator::DirectionsSummary* DirectionsRoute::mutable_summary() {
  set_has_summary();
  if (summary_ == NULL) {
    summary_ = new ::navigator::DirectionsSummary;
  }
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsRoute.summary)
  return summary_;
}
inline void DirectionsRoute::set_allocated_summary(::navigator::DirectionsSummary* summary) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete summary_;
  }
  if (summary) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      summary = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, summary, submessage_arena);
    }
    set_has_summary();
  } else {
    clear_has_summary();
  }
  summary_ = summary;
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsRoute.summary)
}

// repeated .navigator.DirectionsLeg legs = 2;
inline int DirectionsRoute::legs_size() const {
  return legs_.size();
}
inline void DirectionsRoute::clear_legs() {
  legs_.Clear();
}
inline const ::navigator::DirectionsLeg& DirectionsRoute::legs(int index) const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsRoute.legs)
  return legs_.Get(index);
}
inline ::navigator::DirectionsLeg* DirectionsRoute::mutable_legs(int index) {
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsRoute.legs)
  return legs_.Mutable(index);
}
inline ::navigator::DirectionsLeg* DirectionsRoute::add_legs() {
  // @@protoc_insertion_point(field_add:navigator.DirectionsRoute.legs)
  return legs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLeg >*
DirectionsRoute::mutable_legs() {
  // @@protoc_insertion_point(field_mutable_list:navigator.DirectionsRoute.legs)
  return &legs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLeg >&
DirectionsRoute::legs() const {
  // @@protoc_insertion_point(field_list:navigator.DirectionsRoute.legs)
  return legs_;
}

// optional string voice_locale = 3;
inline bool DirectionsRoute::has_voice_locale() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsRoute::set_has_voice_locale() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsRoute::clear_has_voice_locale() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsRoute::clear_voice_locale() {
  voice_locale_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_voice_locale();
}
inline const ::std::string& DirectionsRoute::voice_locale() const {
  // @@protoc_insertion_point(field_get:navigator.DirectionsRoute.voice_locale)
  return voice_locale_.GetNoArena();
}
inline void DirectionsRoute::set_voice_locale(const ::std::string& value) {
  set_has_voice_locale();
  voice_locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.DirectionsRoute.voice_locale)
}
#if LANG_CXX11
inline void DirectionsRoute::set_voice_locale(::std::string&& value) {
  set_has_voice_locale();
  voice_locale_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.DirectionsRoute.voice_locale)
}
#endif
inline void DirectionsRoute::set_voice_locale(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_voice_locale();
  voice_locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.DirectionsRoute.voice_locale)
}
inline void DirectionsRoute::set_voice_locale(const char* value, size_t size) {
  set_has_voice_locale();
  voice_locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.DirectionsRoute.voice_locale)
}
inline ::std::string* DirectionsRoute::mutable_voice_locale() {
  set_has_voice_locale();
  // @@protoc_insertion_point(field_mutable:navigator.DirectionsRoute.voice_locale)
  return voice_locale_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectionsRoute::release_voice_locale() {
  // @@protoc_insertion_point(field_release:navigator.DirectionsRoute.voice_locale)
  clear_has_voice_locale();
  return voice_locale_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectionsRoute::set_allocated_voice_locale(::std::string* voice_locale) {
  if (voice_locale != NULL) {
    set_has_voice_locale();
  } else {
    clear_has_voice_locale();
  }
  voice_locale_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), voice_locale);
  // @@protoc_insertion_point(field_set_allocated:navigator.DirectionsRoute.voice_locale)
}

// -------------------------------------------------------------------

// Directions

// repeated .navigator.DirectionsLocation locations = 1;
inline int Directions::locations_size() const {
  return locations_.size();
}
inline void Directions::clear_locations() {
  locations_.Clear();
}
inline const ::navigator::DirectionsLocation& Directions::locations(int index) const {
  // @@protoc_insertion_point(field_get:navigator.Directions.locations)
  return locations_.Get(index);
}
inline ::navigator::DirectionsLocation* Directions::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:navigator.Directions.locations)
  return locations_.Mutable(index);
}
inline ::navigator::DirectionsLocation* Directions::add_locations() {
  // @@protoc_insertion_point(field_add:navigator.Directions.locations)
  return locations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLocation >*
Directions::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:navigator.Directions.locations)
  return &locations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsLocation >&
Directions::locations() const {
  // @@protoc_insertion_point(field_list:navigator.Directions.locations)
  return locations_;
}

// repeated .navigator.DirectionsRoute routes = 2;
inline int Directions::routes_size() const {
  return routes_.size();
}
inline void Directions::clear_routes() {
  routes_.Clear();
}
inline const ::navigator::DirectionsRoute& Directions::routes(int index) const {
  // @@protoc_insertion_point(field_get:navigator.Directions.routes)
  return routes_.Get(index);
}
inline ::navigator::DirectionsRoute* Directions::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:navigator.Directions.routes)
  return routes_.Mutable(index);
}
inline ::navigator::DirectionsRoute* Directions::add_routes() {
  // @@protoc_insertion_point(field_add:navigator.Directions.routes)
  return routes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsRoute >*
Directions::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:navigator.Directions.routes)
  return &routes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::navigator::DirectionsRoute >&
Directions::routes() const {
  // @@protoc_insertion_point(field_list:navigator.Directions.routes)
  return routes_;
}

// optional .navigator.DirectionsBoundingBox bounding_box = 3;
inline bool Directions::has_bounding_box() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Directions::set_has_bounding_box() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Directions::clear_has_bounding_box() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Directions::clear_bounding_box() {
  if (bounding_box_ != NULL) bounding_box_->Clear();
  clear_has_bounding_box();
}
inline const ::navigator::DirectionsBoundingBox& Directions::bounding_box() const {
  const ::navigator::DirectionsBoundingBox* p = bounding_box_;
  // @@protoc_insertion_point(field_get:navigator.Directions.bounding_box)
  return p != NULL ? *p : *reinterpret_cast<const ::navigator::DirectionsBoundingBox*>(
      &::navigator::_DirectionsBoundingBox_default_instance_);
}
inline ::navigator::DirectionsBoundingBox* Directions::release_bounding_box() {
  // @@protoc_insertion_point(field_release:navigator.Directions.bounding_box)
  clear_has_bounding_box();
  ::navigator::DirectionsBoundingBox* temp = bounding_box_;
  bounding_box_ = NULL;
  return temp;
}
inline ::navigator::DirectionsBoundingBox* Directions::mutable_bounding_box() {
  set_has_bounding_box();
  if (bounding_box_ == NULL) {
    bounding_box_ = new ::navigator::DirectionsBoundingBox;
  }
  // @@protoc_insertion_point(field_mutable:navigator.Directions.bounding_box)
  return bounding_box_;
}
inline void Directions::set_allocated_bounding_box(::navigator::DirectionsBoundingBox* bounding_box) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bounding_box_;
  }
  if (bounding_box) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bounding_box = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bounding_box, submessage_arena);
    }
    set_has_bounding_box();
  } else {
    clear_has_bounding_box();
  }
  bounding_box_ = bounding_box;
  // @@protoc_insertion_point(field_set_allocated:navigator.Directions.bounding_box)
}

// optional string code = 4;
inline bool Directions::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Directions::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Directions::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Directions::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code();
}
inline const ::std::string& Directions::code() const {
  // @@protoc_insertion_point(field_get:navigator.Directions.code)
  return code_.GetNoArena();
}
inline void Directions::set_code(const ::std::string& value) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.Directions.code)
}
#if LANG_CXX11
inline void Directions::set_code(::std::string&& value) {
  set_has_code();
  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.Directions.code)
}
#endif
inline void Directions::set_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.Directions.code)
}
inline void Directions::set_code(const char* value, size_t size) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.Directions.code)
}
inline ::std::string* Directions::mutable_code() {
  set_has_code();
  // @@protoc_insertion_point(field_mutable:navigator.Directions.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Directions::release_code() {
  // @@protoc_insertion_point(field_release:navigator.Directions.code)
  clear_has_code();
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Directions::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    set_has_code();
  } else {
    clear_has_code();
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:navigator.Directions.code)
}

// optional string uuid = 5;
inline bool Directions::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Directions::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Directions::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Directions::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& Directions::uuid() const {
  // @@protoc_insertion_point(field_get:navigator.Directions.uuid)
  return uuid_.GetNoArena();
}
inline void Directions::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navigator.Directions.uuid)
}
#if LANG_CXX11
inline void Directions::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navigator.Directions.uuid)
}
#endif
inline void Directions::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navigator.Directions.uuid)
}
inline void Directions::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navigator.Directions.uuid)
}
inline ::std::string* Directions::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:navigator.Directions.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Directions::release_uuid() {
  // @@protoc_insertion_point(field_release:navigator.Directions.uuid)
  clear_has_uuid();
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Directions::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:navigator.Directions.uuid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace navigator

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::navigator::DirectionsIntersection_Class> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::navigator::DirectionsIntersection_Class>() {
  return ::navigator::DirectionsIntersection_Class_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_directions_2eproto__INCLUDED
